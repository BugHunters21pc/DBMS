SQL
















































i

SQL



About the Tutorial
SQL is a database computer language designed for the retrieval and management of data in a relational database. SQL stands for Structured Query Language.
This tutorial will give you a quick start to SQL. It covers most of the topics required for a basic understanding of SQL and to get a feel of how it works.


Audience
This tutorial is prepared for beginners to help them understand the basic as well as the advanced concepts related to SQL languages. This tutorial will give you enough understanding on the various components of SQL along with suitable examples.


Prerequisites
Before you start practicing with various types of examples given in this tutorial, I am assuming that you are already aware about what a database is, especially the RDBMS and what is a computer programming language.


Compile/Execute SQL Programs
If you are willing to compile and execute SQL programs with Oracle 11g RDBMS but you don’t have a setup for the same, do not worry. Coding Ground is available on a high-end dedicated server giving you real programming experience. It is free and is available online for everyone.


Copyright & Disclaimer
ã Copyright 2017 by Tutorials Point (I) Pvt. Ltd.
All the content and graphics published in this e-book are the property of Tutorials Point (I) Pvt. Ltd. The user of this e-book is prohibited to reuse, retain, copy, distribute or republish any contents or a part of contents of this e-book in any manner without written consent of the publisher.
We strive to update the contents of our website and tutorials as timely and as precisely as possible, however, the contents may contain inaccuracies or errors. Tutorials Point (I) Pvt. Ltd. provides no guarantee regarding the accuracy, timeliness or completeness of our website or its contents including this tutorial. If you discover any errors on our website or in this tutorial, please notify us at contact@tutorialspoint.com

iv


 Table of Contents	

About the Tutorial	i
Audience	i
Prerequisites	i
Compile/Execute SQL Programs	i
Copyright & Disclaimer	i
Table of Contents	ii
1. SQL ─ Overview	1
What is SQL?	1
SQL Process	2
SQL Commands	2
2. SQL ─ RDBMS Concepts	4
What is RDBMS?	4
SQL Constraints	5
Data Integrity	6
Database Normalization	6
Database – First Normal Form (1NF)	7
Database – Second Normal Form (2NF)	9
Database – Third Normal Form (3NF)	10
3. SQL ─ RDBMS Databases	12
MySQL	12
MS SQL Server	13
ORACLE	14
MS ACCESS	15
4. SQL – Syntax	16
Various Syntax in SQL	16
5. SQL ─ Data Types	20
6. SQL – Operators	23
What is an Operator in SQL?	23
SQL Arithmetic Operators	23
Arithmetic Operators – Examples	24
SQL Comparison Operators	25
Comparison Operators – Examples	26
SQL Logical Operators	29
Logical Operators – Examples	30
7. SQL – Expressions	35
Boolean Expressions	35
Numeric Expressions	36
Date Expressions	37
8. SQL – CREATE Database	38
9. SQL ─ DROP or DELETE Database	39
10. SQL ─ SELECT Database, USE Statement	40
11. SQL ─ CREATE Table	41
SQL - Creating a Table from an Existing Table	42
12. SQL ─ DROP or DELETE Table	44
13. SQL ─ INSERT Query	45
14. SQL ─ SELECT Query	47
15. SQL ─ WHERE Clause	49
16. SQL ─ AND & OR Conjunctive Operators	51
The AND Operator	51
The OR Operator	52
17. SQL ─ UPDATE Query	54
18. SQL ─ DELETE Query	56
19. SQL ─ LIKE Clause	58
20. SQL ─ TOP, LIMIT or ROWNUM Clause	61
21. SQL ─ ORDER BY Clause	63
22. SQL ─ Group By	65
23. SQL ─ Distinct Keyword	68
24. SQL ─ SORTING Results	70
25. SQL ─ Constraints	73
SQL - NOT NULL Constraint	73
SQL - DEFAULT Constraint	74
SQL - UNIQUE Constraint	75
SQL ─ Primary Key	76
SQL ─ Foreign Key	77
SQL ─ CHECK Constraint	79
SQL ─ INDEX Constraint	80
Dropping Constraints	81
Integrity Constraints	81
26. SQL ─ Using Joins	82
SQL - INNER JOIN	83
SQL ─ LEFT JOIN	85
SQL - RIGHT JOIN	87
SQL ─ FULL JOIN	88
SQL ─ SELF JOIN	91
SQL ─ CARTESIAN or CROSS JOIN	92
27. SQL ─ UNIONS CLAUSE	95
The UNION ALL Clause	97
SQL ─ INTERSECT Clause	99
SQL ─ EXCEPT Clause	101
28. SQL ─ NULL Values	104
29. SQL ─ Alias Syntax	106
30. SQL – Indexes	109
The CREATE INDEX Command	109
The DROP INDEX Command	110
SQL - INDEX Constraint	110
31. SQL ─ ALTER TABLE Command	112
32. SQL - TRUNCATE TABLE Command	116
33. SQL ─ Using Views	117
Creating Views	117
The WITH CHECK OPTION	118
34. SQL ─ Having Clause	122
35. SQL – Transactions	124
Properties of Transactions	124
Transactional Control Commands	124
36. SQL ─ Wildcard Operators	130
37. SQL ─ Date Functions	133
38. SQL ─ Temporary Tables	162
What are Temporary Tables?	162
Dropping Temporary Tables	163
39. SQL – Clone Tables	164
40. SQL – Sub Queries	166
Subqueries with the SELECT Statement	166
Subqueries with the INSERT Statement	167
Subqueries with the UPDATE Statement	168
Subqueries with the DELETE Statement	169
41. SQL – Using Sequences	171
Using AUTO_INCREMENT column	171
Obtain AUTO_INCREMENT Values	172
Renumbering an Existing Sequence	172
Starting a Sequence at a Particular Value	173
42. SQL – Handling Duplicates	174
43. SQL – Injection	176
Preventing SQL Injection	177












SQL

1.	SQL ─ Overview
SQL is a language to operate databases; it includes database creation, deletion, fetching rows, modifying rows, etc. SQL is an ANSI (American National Standards Institute) standard language, but there are many different versions of the SQL language.

 What is SQL?	
SQL is Structured Query Language, which is a computer language for storing, manipulating and retrieving data stored in a relational database.
SQL is the standard language for Relational Database System. All the Relational Database Management Systems (RDMS) like MySQL, MS Access, Oracle, Sybase, Informix, Postgres and SQL Server use SQL as their standard database language.
Also, they are using different dialects, such as:
· MS SQL Server using T-SQL,
· Oracle using PL/SQL,
· MS Access version of SQL is called JET SQL (native format) etc.

Why SQL?
SQL is widely popular because it offers the following advantages:
· Allows users to access data in the relational database management systems.
· Allows users to describe the data.
· Allows users to define the data in a database and manipulate that data.
· Allows to embed within other languages using SQL modules, libraries & pre-compilers.
· Allows users to create and drop databases and tables.
· Allows users to create view, stored procedure, functions in a database.
· Allows users to set permissions on tables, procedures and views.

A Brief History of SQL
· 1970 – Dr. Edgar F. "Ted" Codd of IBM is known as the father of relational databases. He described a relational model for databases.
· 1974 – Structured Query Language appeared.
· 1978 – IBM worked to develop Codd's ideas and released a product named System/R.
· 1986 – IBM developed the first prototype of relational database and standardized by ANSI. The first relational database was released by Relational Software which later came to be known as Oracle.

1

SQL


 SQL Process	
When you are executing an SQL command for any RDBMS, the system determines the best way to carry out your request and SQL engine figures out how to interpret the task. There are various components included in this process.
These components are –
· Query Dispatcher
· Optimization Engines
· Classic Query Engine
· SQL Query Engine, etc.

A classic query engine handles all the non-SQL queries, but a SQL query engine won't handle logical files.
Following is a simple diagram showing the SQL Architecture:



 SQL Commands	
The standard SQL commands to interact with relational databases are CREATE, SELECT, INSERT, UPDATE, DELETE and DROP. These commands can be classified into the following groups based on their nature:

3


DDL - Data Definition Language

CommandDescriptionCREATECreates a new table, a view of a table, or other object in the database.ALTERModifies an existing database object, such as a table.DROPDeletes an entire table, a view of a table or other objects in the database.DML - Data Manipulation Language

CommandDescriptionSELECTRetrieves certain records from one or more tables.INSERTCreates a record.UPDATEModifies records.DELETEDeletes records.DCL - Data Control Language

CommandDescriptionGRANTGives a privilege to user.REVOKETakes back privileges granted from user.













SQL

2.	SQL ─ RDBMS Concepts
What is RDBMS?
RDBMS stands for Relational Database Management System. RDBMS is the basis for SQL, and for all modern database systems like MS SQL Server, IBM DB2, Oracle, MySQL, and Microsoft Access.
A Relational database management system (RDBMS) is a database management system (DBMS) that is based on the relational model as introduced by E. F. Codd.

What is a table?
The data in an RDBMS is stored in database objects which are called as tables. This table is basically a collection of related data entries and it consists of numerous columns and rows.
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Remember, a table is the most common and simplest form of data storage in a relational database. The following program is an example of a CUSTOMERS table:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

What is a field?
Every table is broken up into smaller entities called fields. The fields in the CUSTOMERS table consist of ID, NAME, AGE, ADDRESS and SALARY.
A field is a column in a table that is designed to maintain specific information about every record in the table.

What is a Record or a Row?
A record is also called as a row of data is each individual entry that exists in a table. For example, there are 7 records in the above CUSTOMERS table. Following is a single row of data or record in the CUSTOMERS table:

4

SQL





+	+	+	+	+	+
|	1 | Ramesh	|	32 | Ahmedabad |	2000.00 |
+	+	+	+	+	+

A record is a horizontal entity in a table.

What is a column?
A column is a vertical entity in a table that contains all information associated with a specific field in a table.
+	+
| ADDRESS	|
+	+
| Ahmedabad |
| Delhi
| Kota
| Mumbai
| Bhopal
| MP
| Indore
+	+ 	
|
|
|
|
|
|
+
For example, a column in the CUSTOMERS table is ADDRESS, which represents location description and would be as shown below:


What is a NULL value?
A NULL value in a table is a value in a field that appears to be blank, which means a field with a NULL value is a field with no value.
It is very important to understand that a NULL value is different than a zero value or a field that contains spaces. A field with a NULL value is the one that has been left blank during a record creation.

 SQL Constraints	
Constraints are the rules enforced on data columns on a table. These are used to limit the type of data that can go into a table. This ensures the accuracy and reliability of the data in the database.
Constraints can either be column level or table level. Column level constraints are applied only to one column whereas, table level constraints are applied to the entire table.


Following are some of the most commonly used constraints available in SQL:

11



· NOT NULL Constraint: Ensures that a column cannot have a NULL value.
· DEFAULT Constraint: Provides a default value for a column when none is specified.
· UNIQUE Constraint: Ensures that all the values in a column are different.
· PRIMARY Key: Uniquely identifies each row/record in a database table.
· FOREIGN Key: Uniquely identifies a row/record in any another database table.
· CHECK Constraint: The CHECK constraint ensures that all values in a column satisfy certain conditions.
· INDEX: Used to create and retrieve data from the database very quickly.

 Data Integrity	
The following categories of data integrity exist with each RDBMS:
· Entity Integrity: There are no duplicate rows in a table.
· Domain Integrity: Enforces valid entries for a given column by restricting the type, the format, or the range of values.
· Referential integrity: Rows cannot be deleted, which are used by other records.
· User-Defined Integrity: Enforces some specific business rules that do not fall into entity, domain or referential integrity.

 Database Normalization	
Database normalization is the process of efficiently organizing data in a database. There are two reasons of this normalization process:
· Eliminating redundant data. For example, storing the same data in more than one table.
· Ensuring data dependencies make sense.
Both these reasons are worthy goals as they reduce the amount of space a database consumes and ensures that data is logically stored. Normalization consists of a series of guidelines that help guide you in creating a good database structure.
Normalization guidelines are divided into normal forms; think of a form as the format or the way a database structure is laid out. The aim of normal forms is to organize the database structure, so that it complies with the rules of first normal form, then second normal form and finally the third normal form.
It is your choice to take it further and go to the fourth normal form, fifth normal form and so on, but in general, the third normal form is more than enough.

· First Normal Form (1NF)

· Second Normal Form (2NF)

· Third Normal Form (3NF)


 Database – First Normal Form (1NF)	
The First normal form (1NF) sets basic rules for an organized database:
· Define the data items required, because they become the columns in a table.
· Place the related data items in a table.
· Ensure that there are no repeating groups of data.
· Ensure that there is a primary key.

First Rule of 1NF
You must define the data items. This means looking at the data to be stored, organizing the data into columns, defining what type of data each column contains and then finally putting the related columns into their own table.
For example, you put all the columns relating to locations of meetings in the Location table, those relating to members in the MemberDetails table and so on.

Second Rule of 1NF
The next step is ensuring that there are no repeating groups of data. Consider we have the following table:
CREATE  TABLE  CUSTOMERS(
ID	INT
NAME VARCHAR (20) AGE	INT
NOT  NULL,
NOT  NULL, NOT  NULL,
ADDRESS	CHAR  (25),
ORDERS	VARCHAR(155)
);

So, if we populate this table for a single customer having multiple orders, then it would be something as shown below:

IDNAMEAGEADDRESSORDERS100Sachin36Lower West SideCannon XL-200100Sachin36Lower West SideBattery XL-200100Sachin36Lower West SideTripod Large
But as per the 1NF, we need to ensure that there are no repeating groups of data. So, let us break the above table into two parts and then join them using a key as shown in the following program:





CREATE  TABLE  CUSTOMERS(
ID	INT
NAME VARCHAR (20)
AGE	INT
ADDRESS	CHAR  (25), PRIMARY  KEY  (ID)
NOT  NULL,
NOT  NULL, NOT  NULL,
);
CUSTOMERS Table
This table would have the following record:

IDNAMEAGEADDRESS100Sachin36Lower West Side
CREATE  TABLE  ORDERS(
ID	INT CUSTOMER_ID  INT
NOT  NULL,
NOT  NULL,
ORDERS	VARCHAR(155),
PRIMARY  KEY  (ID)
);
ORDERS Table
This table would have the following records:

IDCUSTOMER_IDORDERS10100Cannon XL-20011100Battery XL-20012100Tripod Large
Third Rule of 1NF
The final rule of the first normal form, create a primary key for each table which we have already created.


 Database – Second Normal Form (2NF)	
The Second Normal Form states that it should meet all the rules for 1NF and there must be no partial dependences of any of the columns on the primary key:
Consider a customer-order relation and you want to store customer ID, customer name, order ID and order detail and the date of purchase:
CREATE  TABLE  CUSTOMERS(
CUST_ID	INT
CUST_NAME VARCHAR (20) ORDER_ID	INT
ORDER_DETAIL  VARCHAR  (20)
SALE_DATE	DATETIME,
NOT  NULL,
NOT  NULL, NOT  NULL,
NOT  NULL,
PRIMARY  KEY  (CUST_ID,  ORDER_ID)
);

This table is in the first normal form; in that it obeys all the rules of the first normal form. In this table, the primary key consists of the CUST_ID and the ORDER_ID. Combined, they are unique assuming the same customer would hardly order the same thing.
However, the table is not in the second normal form because there are partial dependencies of primary keys and columns. CUST_NAME is dependent on CUST_ID and there's no real link between a customer's name and what he purchased. The order detail and purchase date are also dependent on the ORDER_ID, but they are not dependent on the CUST_ID, because there is no link between a CUST_ID and an ORDER_DETAIL or their SALE_DATE.
To make this table comply with the second normal form, you need to separate the columns into three tables.
First, create a table to store the customer details as shown in the code block below:
CREATE  TABLE  CUSTOMERS(
CUST_ID	INT
CUST_NAME VARCHAR (20) PRIMARY  KEY  (CUST_ID)
NOT  NULL,
NOT  NULL,
);


The next step is to create a table to store the details of each order:
CREATE TABLE ORDERS(
ORDER_ID	INT
NOT  NULL,
ORDER_DETAIL  VARCHAR  (20)	NOT  NULL,
PRIMARY  KEY  (ORDER_ID)
);


CREATE TABLE ADDRESS(


CREATE  TABLE  CUSTMERORDERS(
PRIMARY  KEY  (CUST_ID,  ORDER_ID)
);
Finally, create a third table storing just the CUST_ID and the ORDER_ID to keep a track of all the orders for a customer:



CUST_IDINTNOT  NULL,ORDER_ID
SALE_DATEINT
DATETIME,NOT  NULL,



Database – Third Normal Form (3NF)
A table is in a third normal form when the following conditions are met:
· It is in the second normal form.
· All non-primary fields are dependent on the primary key.
The dependency of these non-primary fields is between the data. For example, in the following table – the street name, city and the state are unbreakably bound to their zip code.
CREATE  TABLE  CUSTOMERS(
CUST_ID
CUST_NAME DOB STREET CITY STATE
ZIP
EMAIL_ID
INT
VARCHAR (20) DATE, VARCHAR(200), VARCHAR(100), VARCHAR(100), VARCHAR(12),
VARCHAR(256),
NOT  NULL,
NOT  NULL,
PRIMARY  KEY  (CUST_ID)
);

The dependency between the zip code and the address is called as a transitive dependency. To comply with the third normal form, all you need to do is to move the Street, City and the State fields into their own table, which you can call as the Zip Code table.



ZIP
STREETVARCHAR(12),
VARCHAR(200),CITYVARCHAR(100),STATEVARCHAR(100),
);PRIMARYKEY  (ZIP)


The next step is to alter the CUSTOMERS table as shown below.
CREATE  TABLE  CUSTOMERS(
CUST_ID
CUST_NAME DOB
ZIP
EMAIL_ID
INT
VARCHAR (20) DATE, VARCHAR(12),
VARCHAR(256),
NOT  NULL,
NOT  NULL,
PRIMARY  KEY  (CUST_ID)
);


The advantages of removing transitive dependencies are mainly two-fold. First, the amount of data duplication is reduced and therefore your database becomes smaller.
The second advantage is data integrity. When duplicated data changes, there is a big risk of updating only some of the data, especially if it is spread out in many different places in the database.
For example, if the address and the zip code data were stored in three or four different tables, then any changes in the zip codes would need to ripple out to every record in those three or four tables.













SQL

3.	SQL ─ RDBMS Databases
There are many popular RDBMS available to work with. This tutorial gives a brief overview of some of the most popular RDBMS’s. This would help you to compare their basic features.

 MySQL	
MySQL is an open source SQL database, which is developed by a Swedish company – MySQL AB. MySQL is pronounced as "my ess-que-ell," in contrast with SQL, pronounced "sequel."
MySQL is supporting many different platforms including Microsoft Windows, the major Linux distributions, UNIX, and Mac OS X.
MySQL has free and paid versions, depending on its usage (non-commercial/commercial) and features. MySQL comes with a very fast, multi-threaded, multi-user and robust SQL database server.

History
· Development of MySQL by Michael Widenius & David Axmark beginning in 1994.
· First internal release on 23rd May 1995.
· Windows Version was released on the 8th January 1998 for Windows 95 and NT.
· Version 3.23: beta from June 2000, production release January 2001.
· Version 4.0: beta from August 2002, production release March 2003 (unions).
· Version 4.01: beta from August 2003, Jyoti adopts MySQL for database tracking.
· Version 4.1: beta from June 2004, production release October 2004.
· Version 5.0: beta from March 2005, production release October 2005.
· Sun Microsystems acquired MySQL AB on the 26th February 2008.
· Version 5.1: production release 27th November 2008.

Features
· High Performance.
· High Availability.
· Scalability and Flexibility Run anything.
· Robust Transactional Support.
· Web and Data Warehouse Strengths.
· Strong Data Protection.
· Comprehensive Application Development.

12

SQL



· Management Ease.
· Open Source Freedom and 24 x 7 Support.
· Lowest Total Cost of Ownership.

 MS SQL Server	
MS SQL Server is a Relational Database Management System developed by Microsoft Inc. Its primary query languages are:
· T-SQL
· ANSI SQL

History
· 1987 - Sybase releases SQL Server for UNIX.
· 1988 - Microsoft, Sybase, and Aston-Tate port SQL Server to OS/2.
· 1989 - Microsoft, Sybase, and Aston-Tate release SQL Server 1.0 for OS/2.
· 1990 - SQL Server 1.1 is released with support for Windows 3.0 clients.
· Aston - Tate drops out of SQL Server development.
· 2000 - Microsoft releases SQL Server 2000.
· 2001 - Microsoft releases XML for SQL Server Web Release 1 (download).
· 2002 - Microsoft releases SQLXML 2.0 (renamed from XML for SQL Server).
· 2002 - Microsoft releases SQLXML 3.0.
· 2005 - Microsoft releases SQL Server 2005 on November 7th, 2005.

Features
· High Performance
· High Availability
· Database mirroring
· Database snapshots
· CLR integration
· Service Broker
· DDL triggers
· Ranking functions
· Row version-based isolation levels
· XML integration
· TRY...CATCH
· Database Mail

15


 ORACLE	
It is a very large multi-user based database management system. Oracle is a relational database management system developed by 'Oracle Corporation'.
Oracle works to efficiently manage its resources, a database of information among the multiple clients requesting and sending data in the network.
It is an excellent database server choice for client/server computing. Oracle supports all major operating systems for both clients and servers, including MSDOS, NetWare, UnixWare, OS/2 and most UNIX flavors.

History
Oracle began in 1977 and celebrating its 32 wonderful years in the industry (from 1977 to 2009).
· 1977 - Larry Ellison, Bob Miner and Ed Oates founded Software Development Laboratories to undertake development work.
· 1979 - Version 2.0 of Oracle was released and it became first commercial relational database and first SQL database. The company changed its name to Relational Software Inc. (RSI).
· 1981 - RSI started developing tools for Oracle.
· 1982 - RSI was renamed to Oracle Corporation.
· 1983 - Oracle released version 3.0, rewritten in C language and ran on multiple platforms.
· 1984 - Oracle version 4.0 was released. It contained features like concurrency control - multi-version read consistency, etc.
· 1985 - Oracle version 4.0 was released. It contained features like concurrency control - multi-version read consistency, etc.
· 2007 - Oracle released Oracle11g. The new version focused on better partitioning, easy migration, etc.

Features
· Concurrency
· Read Consistency
· Locking Mechanisms
· Quiesce Database
· Portability
· Self-managing database
· SQL*Plus
· ASM
· Scheduler
· Resource Manager



· Data Warehousing
· Materialized views
· Bitmap indexes
· Table compression
· Parallel Execution
· Analytic SQL
· Data mining
· Partitioning

 MS ACCESS	
This is one of the most popular Microsoft products. Microsoft Access is an entry-level database management software. MS Access database is not only inexpensive but also a powerful database for small-scale projects.
MS Access uses the Jet database engine, which utilizes a specific SQL language dialect (sometimes referred to as Jet SQL).
MS Access comes with the professional edition of MS Office package. MS Access has easy- to-use intuitive graphical interface.
· 1992 - Access version 1.0 was released.
· 1993 - Access 1.1 released to improve compatibility with inclusion the Access Basic programming language.
· The most significant transition was from Access 97 to Access 2000
· 2007 - Access 2007, a new database format was introduced ACCDB which supports complex data types such as multi valued and attachment fields.

Features
· Users can create tables, queries, forms and reports and connect them together with macros.
· Option of importing and exporting the data to many formats including Excel, Outlook, ASCII, dBase, Paradox, FoxPro, SQL Server, Oracle, ODBC, etc.
· There is also the Jet Database format (MDB or ACCDB in Access 2007), which can contain the application and data in one file. This makes it very convenient to distribute the entire application to another user, who can run it in disconnected environments.
· Microsoft Access offers parameterized queries. These queries and Access tables can be referenced from other programs like VB6 and .NET through DAO or ADO.
· The desktop editions of Microsoft SQL Server can be used with Access as an alternative to the Jet Database Engine.
· Microsoft Access is a file server-based database. Unlike the client-server relational database management systems (RDBMS), Microsoft Access does not implement database triggers, stored procedures or transaction logging.













SQL

4.	SQL – Syntax
SQL is followed by a unique set of rules and guidelines called Syntax. This tutorial gives you a quick start with SQL by listing all the basic SQL Syntax.
All the SQL statements start with any of the keywords like SELECT, INSERT, UPDATE, DELETE, ALTER, DROP, CREATE, USE, SHOW and all the statements end with a semicolon (;).
The most important point to be noted here is that SQL is case insensitive, which means SELECT and select have same meaning in SQL statements. Whereas, MySQL makes difference in table names. So, if you are working with MySQL, then you need to give table names as they exist in the database.

 Various Syntax in SQL	

All the examples given in this tutorial have been tested with a MySQL server.

SQL SELECT Statement
SELECT column1, column2.	columnN
FROM	table_name;


SQL DISTINCT Clause
SELECT  DISTINCT column1, column2.	columnN
FROM	table_name;


SQL WHERE Clause
SELECT  column1,  column2 	columnN
FROM	table_name WHERE	CONDITION;


SQL AND/OR Clause
SELECT column1, column2.	columnN
FROM	table_name
WHERE	CONDITION-1  {AND|OR}  CONDITION-2;


16

SQL



SQL IN Clause
SELECT column1, column2.	columnN
FROM	table_name
WHERE	column_name  IN  (val-1,  val-2, 	val-N);


SQL BETWEEN Clause
SELECT column1, column2.	columnN
FROM	table_name
WHERE	column_name  BETWEEN  val-1  AND  val-2;


SQL LIKE Clause
SELECT column1, column2.	columnN
FROM	table_name
WHERE	column_name LIKE { PATTERN };


SQL ORDER BY Clause
SELECT column1, column2.	columnN
FROM	table_name WHERE	CONDITION
ORDER  BY  column_name  {ASC|DESC};


SQL GROUP BY Clause
SELECT  SUM(column_name) FROM	table_name   WHERE	CONDITION
GROUP BY column_name;


SQL COUNT Clause
SELECT  COUNT(column_name) FROM	table_name
WHERE	CONDITION;






SQL HAVING Clause

19



SELECT  SUM(column_name) FROM	table_name   WHERE	CONDITION
GROUP BY column_name
HAVING (arithematic function condition);


SQL CREATE TABLE Statement
CREATE TABLE table_name( column1  datatype, column2 datatype, column3 datatype,
.....
columnN datatype,
PRIMARY KEY( one or more columns )
);


SQL DROP TABLE Statement
DROP TABLE table_name;


SQL CREATE INDEX Statement
CREATE UNIQUE INDEX index_name
ON  table_name  (  column1,  column2,...columnN);


SQL DROP INDEX Statement
ALTER  TABLE  table_name DROP INDEX index_name;


SQL DESC Statement
DESC table_name;


SQL TRUNCATE TABLE Statement
TRUNCATE TABLE table_name;


SQL ALTER TABLE Statement
ALTER  TABLE  table_name  {ADD|DROP|MODIFY}  column_name  {data_ype};




SQL ALTER TABLE Statement (Rename)
ALTER  TABLE  table_name  RENAME  TO  new_table_name;


SQL INSERT INTO Statement
INSERT  INTO  table_name(  column1,  column2. 	columnN)
VALUES ( value1, value2.	valueN);


SQL UPDATE Statement
UPDATE  table_name
SET  column1  =  value1,  column2  =  value2 	columnN=valueN
[ WHERE	CONDITION ];


SQL DELETE Statement
DELETE  FROM  table_name WHERE	{CONDITION};


SQL CREATE DATABASE Statement
CREATE DATABASE database_name;


SQL DROP DATABASE Statement
DROP DATABASE database_name;


SQL USE Statement
USE database_name;


SQL COMMIT Statement
COMMIT;


SQL ROLLBACK Statement
ROLLBACK;














SQL

5.	SQL ─ Data Types
SQL Data Type is an attribute that specifies the type of data of any object. Each column, variable and expression has a related data type in SQL. You can use these data types while creating your tables. You can choose a data type for a table column based on your requirement.
SQL Server offers six categories of data types for your use which are listed below −

Exact Numeric Data Types

DATA TYPEFROMTObigint-9,223,372,036,854,775,8089,223,372,036,854,775,807int-2,147,483,6482,147,483,647smallint-32,76832,767tinyint0255bit01decimal-10^38 +110^38 -1numeric-10^38 +110^38 -1money-922,337,203,685,477.5808+922,337,203,685,477.5807smallmoney-214,748.3648+214,748.3647Approximate Numeric Data Types

DATA TYPEFROMTOfloat-1.79E + 3081.79E + 308real-3.40E + 383.40E + 38
20

SQL


Date and Time Data Types

DATA TYPEFROMTOdatetimeJan 1, 1753Dec 31, 9999smalldatetimeJan 1, 1900Jun 6, 2079dateStores a date like June 30, 1991timeStores a time of day like 12:30 P.M.Note − Here, datetime has 3.33 milliseconds accuracy where as smalldatetime has 1 minute accuracy.

Character Strings Data Types

DATA TYPEDescriptioncharMaximum length of 8,000 characters.( Fixed length non- Unicode characters)varcharMaximum of 8,000 characters.(Variable-length non-Unicode data).varchar(max)Maximum	length	of	231characters,	Variable-length	non- Unicode data (SQL Server 2005 only).textVariable-length non-Unicode data with a maximum length of 2,147,483,647 characters.Unicode Character Strings Data Types

DATA TYPEDescriptionncharMaximum length of 4,000 characters.( Fixed length Unicode)nvarcharMaximum length of 4,000 characters.(Variable length Unicode)
nvarchar(max)Maximum length of 231characters (SQL Server 2005 only).( Variable length Unicode)
22




ntextMaximum length of 1,073,741,823 characters. ( Variable length Unicode )
Binary Data Types

DATA TYPEDescriptionbinaryMaximum length of 8,000 bytes(Fixed-length binary data )varbinaryMaximum length of 8,000 bytes.(Variable length binary data)
varbinary(max)Maximum length of 231 bytes (SQL Server 2005 only). ( Variable length Binary data)
imageMaximum length of 2,147,483,647 bytes. ( Variable length Binary Data)
Misc Data Types

DATA TYPEDescription
sql_variantStores values of various SQL Server-supported data types, except text, ntext, and timestamp.
timestampStores a database-wide unique number that gets updated every time a row gets updateduniqueidentifierStores a globally unique identifier (GUID)
xmlStores XML data. You can store xml instances in a column or a variable (SQL Server 2005 only).cursorReference to a cursor objecttableStores a result set for later processing













SQL

6.	SQL – Operators
What is an Operator in SQL?

An operator is a reserved word or a character used primarily in an SQL statement's WHERE clause to perform operation(s), such as comparisons and arithmetic operations. These Operators are used to specify conditions in an SQL statement and to serve as conjunctions for multiple conditions in a statement.

· Arithmetic operators

· Comparison operators

· Logical operators

· Operators used to negate conditions

 SQL Arithmetic Operators	

Assume ‘variable a’ holds 10 and ‘variable b’ holds 20, then:


Operator
Description
Example
+
Addition - Adds values on either side of the operator.
a + b will give 30
-
Subtraction - Subtracts right hand operand from left hand operand.
a - b will give -10
*
Multiplication - Multiplies values on either side of the operator.
a * b will give 200
/
Division - Divides left hand operand by right hand operand.
b / a will give 2
%
Modulus - Divides left hand operand by right hand operand and returns remainder.
b % a will give 0
23

SQL


Arithmetic Operators – Examples

Here are a few simple examples showing the usage of SQL Arithmetic Operators:

Example 1:
SQL> select 10+ 20;


Output:
+	+
| 10+  20 |
+	+
|	30 |
+	+
1 row in set (0.00 sec)


Example 2:
SQL>  select  10  *  20;


Output:
+	+
| 10  * 20 |
+	+
|	200 |
+	+
1 row in set (0.00 sec)


Example 3:
SQL> select 10 / 5;


Output:
+	+
| 10  / 5 |
+	+
| 2.0000 |
+	+
1 row in set (0.03 sec)


Example 4:

30



SQL>  select  12  %	5;


Output:
+	+
| 12 %	5 |
+	+
|	2 |
+	+
1  row  in  set  (0.00  sec)


 SQL Comparison Operators	

Assume ‘variable a’ holds 10 and ‘variable b’ holds 20, then:


Operator
Description
Example
=
Checks if the values of two operands are equal or not, if yes then condition becomes true.
(a = b) is not true.
!=
Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.
(a != b) is true.
<>
Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.
(a <> b) is true.
>
Checks if the value of left operand is greater than the value of right operand, if yes then condition becomes true.
(a > b) is not true.
<
Checks if the value of left operand is less than the value of right operand, if yes then condition becomes true.
(a < b) is true.
>=
Checks if the value of left operand is greater than or equal to the value of right operand, if yes then condition becomes true.
(a >= b) is	not
true.



<=
Checks if the value of left operand is less than or equal to the value of right operand, if yes then condition becomes true.
(a <= b) is true.
!<
Checks if the value of left operand is not less than the value of right operand, if yes then condition becomes true.
(a !< b) is false.
!>
Checks if the value of left operand is not greater than the value of right operand, if yes then condition becomes true.
(a !> b) is true.
Comparison Operators – Examples

SQL> SELECT * FROM CUSTOMERS;
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
7  rows  in  set  (0.00  sec)
Consider the CUSTOMERS table having the following records:







|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|



Here are some simple examples showing the usage of SQL Comparison Operators:

Example 1:
SQL> SELECT * FROM CUSTOMERS WHERE SALARY > 5000;




+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS | SALARY
+	+	+	+	+ 	
+
|
+
|
|
|
4  |  Chaitali  |
5 | Hardik
7  |  Muffy
|
|
25 | Mumbai	|	6500.00 |
27 | Bhopal	|	8500.00 |
24 | Indore	| 10000.00 |
+	+	+	+	+	+
3  rows  in  set  (0.00  sec)
Output:


Example 2:
SQL>	SELECT * FROM CUSTOMERS WHERE SALARY = 2000;


Output:
+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
|	1 | Ramesh	|	32 | Ahmedabad | 2000.00 |
|	3  |  kaushik  |	23  |  Kota	|  2000.00  |
+	+	+	+	+	+
2  rows  in  set  (0.00  sec)


Example 3:
SQL>	SELECT  *  FROM  CUSTOMERS  WHERE  SALARY  !=  2000;


+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS | SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+
5  rows  in  set  (0.00  sec)
Output:






|2|Khilan|25|Delhi|1500.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|



Example 4:
SQL> SELECT * FROM CUSTOMERS WHERE SALARY <> 2000;


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS | SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
5  rows  in  set  (0.00  sec)
Output:






|2|Khilan|25|Delhi|1500.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|



Example 5:
SQL> SELECT * FROM CUSTOMERS WHERE SALARY >= 6500;


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS | SALARY
+	+	+	+	+ 	
+
|
+
|
|
|
4  |  Chaitali  |
5 | Hardik
7  |  Muffy
|
|
25 | Mumbai	|	6500.00 |
27 | Bhopal	|	8500.00 |
24 | Indore	| 10000.00 |
+	+	+	+	+	+
3  rows  in  set  (0.00  sec)
Output:



 SQL Logical Operators	
Here is a list of all the logical operators available in SQL.


Operator
Description
ALL
The ALL operator is used to compare a value to all values in another value set.
AND
The AND operator allows the existence of multiple conditions in an SQL statement's WHERE clause.
ANY
The ANY operator is used to compare a value to any applicable value in the list as per the condition.
BETWEEN
The BETWEEN operator is used to search for values that are within a set of values, given the minimum value and the maximum value.
EXISTS
The EXISTS operator is used to search for the presence of a row in a specified table that meets a certain criterion.
IN
The IN operator is used to compare a value to a list of literal values that have been specified.
LIKE
The LIKE operator is used to compare a value to similar values using wildcard operators.
NOT
The NOT operator reverses the meaning of the logical operator with which it is used. Eg: NOT EXISTS, NOT BETWEEN, NOT IN, etc. This is a negate operator.
OR
The OR operator is used to combine multiple conditions in an SQL statement's WHERE clause.
IS NULL
The NULL operator is used to compare a value with a NULL value.



UNIQUE
The UNIQUE operator searches every row of a specified table for uniqueness (no duplicates).
 Logical Operators– Examples	

Consider the CUSTOMERS table having the following records:







|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|



SQL> SELECT * FROM CUSTOMERS;
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	-+	+	+ 	
+
|
+
+	+	+	+	+	+
7  rows  in  set  (0.00  sec)
Here are some simple examples showing usage of SQL Comparison Operators:
Example 1:
SQL>  SELECT  *  FROM  CUSTOMERS  WHERE  AGE  >=  25  AND  SALARY  >=  6500;

Output:
+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS | SALARY	|
+	+	+	+	+	+
|	4  |  Chaitali  |	25  |  Mumbai	|  6500.00  |
|	5  |  Hardik	|	27  |  Bhopal	|  8500.00  |
+	+	+	+	+	+
2  rows  in  set  (0.00  sec)


SQL
Example 2:


SQL> SELECT * FROM CUSTOMERS WHERE AGE >= 25 OR SALARY >= 6500;


+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+
5  rows  in  set  (0.00  sec)
Output:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||7|Muffy|24|Indore|10000.00|





Example 3:
SQL>	SELECT  *  FROM  CUSTOMERS  WHERE  AGE  IS  NOT  NULL;


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
7  rows  in  set  (0.00  sec)
Output:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

31

SQL



Example 4:
SQL>  SELECT  *  FROM  CUSTOMERS  WHERE  NAME  LIKE  'Ko%';


Output:
+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS | SALARY	|
+	+	+	+	+	+
|	6  | Komal |	22 | MP	|  4500.00 |
+	+	+	+	+	+
1 row in set (0.00 sec)


Example 5:
SQL> SELECT * FROM CUSTOMERS WHERE AGE IN ( 25, 27 );

Output:


+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS | SALARY	|
+	+	+	+	+	+
|
|
|
2 | Khilan
|
4  |  Chaitali  |
5 | Hardik
|
25  |  Delhi	|  1500.00  |
25 | Mumbai	| 6500.00 |
27 | Bhopal	| 8500.00 |
+	+	+	+	+	+
3  rows  in  set  (0.00  sec)
Example 6:
SQL> SELECT * FROM CUSTOMERS WHERE AGE BETWEEN 25 AND 27;


+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS | SALARY	|
+	+	+	+	+	+
|
|
|
2 | Khilan
|
4  |  Chaitali  |
5 | Hardik
|
25 | Delhi	| 1500.00 |
25 | Mumbai	| 6500.00 |
27  |  Bhopal	|  8500.00  |
+	+	+	+	+	+
3  rows  in  set  (0.00  sec)
Output:


Example 7:

34



SQL> SELECT AGE FROM CUSTOMERS
WHERE EXISTS (SELECT AGE FROM CUSTOMERS WHERE SALARY > 6500);


Output:
+	+
| AGE |
+	+
|	32 |
|	25 |
|	23 |
|	25 |
|	27 |
|	22 |
|	24 |
+	+
7  rows  in  set  (0.02  sec)




Example 8:
SQL> SELECT * FROM CUSTOMERS
WHERE AGE > ALL (SELECT AGE FROM CUSTOMERS WHERE SALARY > 6500);


Output:
+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
|	1 | Ramesh |	32 | Ahmedabad | 2000.00 |
+	+	+	+	+	+
1 row in set (0.02 sec)










Example 9:



SQL> SELECT * FROM CUSTOMERS
WHERE  AGE  >  ANY  (SELECT  AGE  FROM  CUSTOMERS  WHERE  SALARY  >  6500);


+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+
4  rows  in  set  (0.00  sec)
Output:






|1|Ramesh|32|Ahmedabad|2000.00 ||2|Khilan|25|Delhi|1500.00 ||4|Chaitali|25|Mumbai|6500.00  ||5|Hardik|27|Bhopal|8500.00 |













SQL

7.	SQL – Expressions
An expression is a combination of one or more values, operators and SQL functions that evaluate to a value. These SQL EXPRESSIONs are like formulae and they are written in query language. You can also use them to query the database for a specific set of data.

Syntax
Consider the basic syntax of the SELECT statement as follows:
SELECT column1, column2, columnN FROM table_name
WHERE [CONDITION|EXPRESSION];

There are different types of SQL expressions, which are mentioned below:
· Boolean
· Numeric
· Date

Let us now discuss each of these in detail.

 Boolean Expressions	
SQL Boolean Expressions fetch the data based on matching a single value. Following is the syntax:
SELECT column1, column2, columnN FROM table_name
WHERE SINGLE VALUE MATCHING EXPRESSION;


SQL> SELECT * FROM CUSTOMERS;
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
Consider the CUSTOMERS table having the following records:







|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00|
35

SQL





|	5 | Hardik	|	27 | Bhopal
|	6 | Komal	|	22 | MP
|	7  |  Muffy	|	24  |  Indore
|	8500.00 |
|	4500.00 |
|  10000.00  |
+	+	+	+	+	+
7  rows  in  set  (0.00  sec)
SQL> SELECT * FROM CUSTOMERS WHERE SALARY = 10000;
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS | SALARY
+	+	+	+	+ 	
+
|
+
|	7  |  Muffy  |	24  |  Indore	|  10000.00  |
+	+	+	+	+	+
1 row in set (0.00 sec)
The following table is a simple example showing the usage of various SQL Boolean Expressions:


Numeric Expressions

These expressions are used to perform any mathematical operation in any query. Following is the syntax:
SELECT  numerical_expression  as	OPERATION_NAME [FROM table_name
WHERE CONDITION] ;


Here, the numerical_expression is used for a mathematical expression or any formula. Following is a simple example showing the usage of SQL Numeric Expressions:
SQL> SELECT (15 + 6) AS ADDITION
+	+
| ADDITION |
+	+
|	21 |
+	+
1 row in set (0.00 sec)


There are several built-in functions like avg(), sum(), count(), etc., to perform what is known as the aggregate data calculations against a table or a specific table column.

37



SQL>  SELECT  COUNT(*)  AS  "RECORDS"  FROM  CUSTOMERS;
+	+
| RECORDS |
+	+
|	7 |
+	+
1  row  in  set  (0.00  sec)


Date Expressions

Date Expressions return the current system date and time values:
SQL>	SELECT  CURRENT_TIMESTAMP;
+	+
| Current_Timestamp	|
+	+
|  2009-11-12  06:40:23  |
+	+
1  row  in  set  (0.00  sec)


Another date expression is as shown below:
SQL>	SELECT	GETDATE();;
+	+
| GETDATE	|
+	+
|  2009-10-22  12:07:18.140  |
+	+
1 row in set (0.00 sec)


SQL
8.
SQL – CREATE Database




The SQL CREATE DATABASE statement is used to create a new SQL database.

Syntax
The basic syntax of this CREATE DATABASE statement is as follows:
CREATE DATABASE DatabaseName;

Always the database name should be unique within the RDBMS.

Example
If you want to create a new database <testDB>, then the CREATE DATABASE statement would be as shown below:
SQL> CREATE DATABASE testDB;

Make sure you have the admin privilege before creating any database. Once a database is created, you can check it in the list of databases as follows:
SQL>  SHOW  DATABASES;
+	+
| Database	|
+	+
| information_schema |
| AMROOD	|
| TUTORIALSPOINT	|
| mysql	|
| orig	|
| test	|
| testDB	|
+	+
7  rows  in  set  (0.00  sec)


38

SQL
9.
SQL ─ DROP or DELETE Database




The SQL DROP DATABASE statement is used to drop an existing database in SQL schema.

Syntax
The basic syntax of DROP DATABASE statement is as follows:
DROP DATABASE DatabaseName;

Always the database name should be unique within the RDBMS.

Example
If you want to delete an existing database <testDB>, then the DROP DATABASE statement would be as shown below:
SQL> DROP DATABASE testDB;

NOTE: Be careful before using this operation because by deleting an existing database would result in loss of complete information stored in the database.
Make sure you have the admin privilege before dropping any database. Once a database is dropped, you can check it in the list of the databases as shown below:
SQL>  SHOW  DATABASES;
+	+
| Database	|
+	+
| information_schema |
| AMROOD	|
| TUTORIALSPOINT	|
| mysql	|
| orig	|
| test	|
+	+
6  rows  in  set  (0.00  sec)


39

SQL
10.
SQL ─ SELECT Database, USE Statement




When you have multiple databases in your SQL Schema, then before starting your operation, you would need to select a database where all the operations would be performed.
The SQL USE statement is used to select any existing database in the SQL schema.

Syntax
The basic syntax of the USE statement is as shown below:
USE DatabaseName;


Always the database name should be unique within the RDBMS.

Example
You can check the available databases as shown below:
SQL>  SHOW  DATABASES;
+	+
| Database	|
+	+
| information_schema |
| AMROOD	|
| TUTORIALSPOINT	|
| mysql	|
| orig	|
| test	|
+	+
6  rows  in  set  (0.00  sec)


Now, if you want to work with the AMROOD database, then you can execute the following SQL command and start working with the AMROOD database.
SQL> USE AMROOD;


40

SQL
11.
SQL ─ CREATE Table




Creating a basic table involves naming the table and defining its columns and each column's data type.
The SQL CREATE TABLE statement is used to create a new table.

Syntax
The basic syntax of the CREATE TABLE statement is as follows:
CREATE TABLE table_name( column1  datatype, column2  datatype, column3  datatype,
.....
columnN  datatype,
PRIMARY  KEY(  one  or  more  columns  )
);

CREATE TABLE is the keyword telling the database system what you want to do. In this case, you want to create a new table. The unique name or identifier for the table follows the CREATE TABLE statement.
Then in brackets comes the list defining each column in the table and what sort of data type it is. The syntax becomes clearer with the following example.
A copy of an existing table can be created using a combination of the CREATE TABLE statement and the SELECT statement. You can check the complete details at Create Table Using another Table.

Example
The following code block is an example, which creates a CUSTOMERS table with an ID as a primary key and NOT NULL are the constraints showing that these fields cannot be NULL while creating records in this table:
SQL> CREATE TABLE CUSTOMERS(
ID	INT
NAME VARCHAR (20)
AGE	INT
NOT  NULL,
NOT  NULL, NOT  NULL,
ADDRESS	CHAR (25) ,
SALARY	DECIMAL  (18,  2), PRIMARY  KEY  (ID)
);


41

SQL



SQL>  DESC  CUSTOMERS;
+ 	
| Field
+ 	
+	+	+	+	+
| Type
|  Null  |  Key  |  Default  |  Extra  |
+	+	+	+	+	+	+
+	+	+	+	+	+	+
5  rows  in  set  (0.00  sec)
You can verify if your table has been created successfully by looking at the message displayed by the SQL server, otherwise you can use the DESC command as follows:







|ID|int(11)|NO|PRI||||NAME|varchar(20)|NO|||||AGE|int(11)|NO|||||ADDRESS|char(25)|YES|| NULL|||SALARY|decimal(18,2)|YES|| NULL||



Now, you have CUSTOMERS table available in your database which you can use to store the required information related to customers.

 SQL - Creating a Table from an Existing Table	

A copy of an existing table can be created using a combination of the CREATE TABLE statement and the SELECT statement. The new table has the same column definitions. All columns or specific columns can be selected. When you will create a new table using the existing table, the new table would be populated using the existing values in the old table.

Syntax
The basic syntax for creating a table from another table is as follows:
CREATE TABLE NEW_TABLE_NAME AS
SELECT  [  column1,  column2...columnN  ]
FROM  EXISTING_TABLE_NAME [ WHERE ]

Here, column1, column2... are the fields of the existing table and the same would be used to create fields of the new table.

Example
Following is an example which would create a table SALARY using the CUSTOMERS table and having the fields – customer ID and customer SALARY:
SQL> CREATE TABLE SALARY AS SELECT  ID,  SALARY
FROM  CUSTOMERS;


43



+	+	+
+	+	+
This would create a new table SALARY which will have the following records.



| ID| SALARY|+ 	+ 	+|	1|	2000.00||	2|	1500.00||	3|	2000.00||	4|	6500.00||	5|	8500.00||	6|	4500.00||	7| 10000.00|

SQL
12.
SQL ─ DROP or DELETE Table




The SQL DROP TABLE statement is used to remove a table definition and all the data, indexes, triggers, constraints and permission specifications for that table.
NOTE: You should be very careful while using this command because once a table is deleted then all the information available in that table will also be lost forever.

Syntax
The basic syntax of this DROP TABLE statement is as follows:
DROP TABLE table_name;

Example
SQL>  DESC  CUSTOMERS;
+ 	
| Field
+ 	
+	+	+	+	+
| Type
|  Null  |  Key  |  Default  |  Extra  |
+	+	+	+	+	+	+
+	+	+	+	+	+	+
5  rows  in  set  (0.00  sec)
Let us first verify the CUSTOMERS table and then we will delete it from the database as shown below.







|ID|int(11)|NO|PRI||||NAME|varchar(20)|NO|||||AGE|int(11)|NO|||||ADDRESS|char(25)|YES|| NULL|||SALARY|decimal(18,2)|YES|| NULL||



This means that the CUSTOMERS table is available in the database, so let us now drop it as shown below.
SQL>  DROP  TABLE  CUSTOMERS;
Query  OK,  0  rows  affected  (0.01  sec)


Now, if you would try the DESC command, then you will get the following error:
SQL>  DESC  CUSTOMERS;
ERROR  1146  (42S02):  Table  'TEST.CUSTOMERS'  doesn't  exist


Here, TEST is the database name which we are using for our examples.

44

SQL
13.
SQL ─ INSERT Query




The SQL INSERT INTO Statement is used to add new rows of data to a table in the database.

Syntax
There are two basic syntaxes of the INSERT INTO statement which are shown below.
INSERT  INTO  TABLE_NAME  (column1,  column2,  column3,...columnN)] VALUES  (value1,  value2,  value3,...valueN);


Here, column1, column2, column3,...columnN are the names of the columns in the table into which you want to insert the data.
You may not need to specify the column(s) name in the SQL query if you are adding values for all the columns of the table. But make sure the order of the values is in the same order as the columns in the table.
The SQL INSERT INTO syntax will be as follows:
INSERT  INTO  TABLE_NAME  VALUES  (value1,value2,value3,...valueN);

Example
The following statements would create six records in the CUSTOMERS table.
INSERT  INTO  CUSTOMERS  (ID,NAME,AGE,ADDRESS,SALARY)
VALUES  (1,  'Ramesh',  32,  'Ahmedabad',  2000.00  );


INSERT  INTO  CUSTOMERS  (ID,NAME,AGE,ADDRESS,SALARY) VALUES  (2,  'Khilan',  25,  'Delhi',  1500.00  );

INSERT  INTO  CUSTOMERS  (ID,NAME,AGE,ADDRESS,SALARY) VALUES  (3,  'kaushik',  23,  'Kota',  2000.00  );

INSERT  INTO  CUSTOMERS  (ID,NAME,AGE,ADDRESS,SALARY) VALUES (4, 'Chaitali', 25, 'Mumbai', 6500.00 );

INSERT  INTO  CUSTOMERS  (ID,NAME,AGE,ADDRESS,SALARY) VALUES (5, 'Hardik', 27, 'Bhopal', 8500.00 );


45


SQL

INSERT  INTO  CUSTOMERS  (ID,NAME,AGE,ADDRESS,SALARY) VALUES  (6,  'Komal',  22,  'MP',  4500.00  );


You can create a record in the CUSTOMERS table by using the second syntax as shown below.
INSERT  INTO  CUSTOMERS
VALUES  (7,  'Muffy',  24,  'Indore',  10000.00  );


+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+
All the above statements would produce the following records in the CUSTOMERS table as shown below.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|


Populate one table using another table
You can populate the data into a table through the select statement over another table; provided the other table has a set of fields, which are required to populate the first table.
Here is the syntax:
INSERT  INTO  first_table_name  [(column1,  column2,  ...  columnN)] SELECT  column1,  column2,  ...columnN
FROM  second_table_name [WHERE  condition];


46













SQL

14.	SQL ─ SELECT Query
The SQL SELECT statement is used to fetch the data from a database table which returns this data in the form of a result table. These result tables are called result-sets.

Syntax
The basic syntax of the SELECT statement is as follows.:
SELECT  column1,  column2,  columnN  FROM  table_name;


Here, column1, column2... are the fields of a table whose values you want to fetch. If you want to fetch all the fields available in the field, then you can use the following syntax.
SELECT * FROM table_name;

Example
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
The following code is an example, which would fetch the ID, Name and Salary fields of the customers available in CUSTOMERS table.
SQL>  SELECT  ID,  NAME,  SALARY  FROM  CUSTOMERS;


47


SQL


+	+	+	+
| ID | NAME	| SALARY	|
+	+	+	+
+	+	+	+
This would produce the following result:






|1|Ramesh|2000.00||2|Khilan|1500.00||3|kaushik|2000.00||4|Chaitali|6500.00||5|Hardik|8500.00||6|Komal|4500.00||7|Muffy|10000.00|

If you want to fetch all the fields of the CUSTOMERS table, then you should use the following query.
SQL> SELECT * FROM CUSTOMERS;


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
This would produce the result as shown below.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

48













SQL

15.	SQL ─ WHERE Clause
The SQL WHERE clause is used to specify a condition while fetching the data from a single table or by joining with multiple tables. If the given condition is satisfied, then only it returns a specific value from the table. You should use the WHERE clause to filter the records and fetching only the necessary records.
The WHERE clause is not only used in the SELECT statement, but it is also used in the UPDATE, DELETE statement, etc., which we would examine in the subsequent chapters.

Syntax
The basic syntax of the SELECT statement with the WHERE clause is as shown below.
SELECT column1, column2, columnN FROM table_name
WHERE [condition]


You can specify a condition using the comparison or logical operators like >, <, =, LIKE, NOT, etc. The following examples would make this concept clear.

Example
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
The following code is an example which would fetch the ID, Name and Salary fields from the CUSTOMERS table, where the salary is greater than 2000:
SQL> SELECT ID, NAME, SALARY FROM CUSTOMERS
WHERE  SALARY  >  2000;


49


SQL


This would produce the following result:






|4|Chaitali|6500.00||5|Hardik|8500.00||6|Komal|4500.00||7|Muffy|10000.00|

+	+	+	+
| ID | NAME	| SALARY	|
+	+	+	+
+	+	+	+
The following query is an example, which would fetch the ID, Name and Salary fields from the CUSTOMERS table for a customer with the name Hardik.

Here, it is important to note that all the strings should be given inside single quotes (''). Whereas, numeric values should be given without any quote as in the above example.
SQL> SELECT ID, NAME, SALARY FROM CUSTOMERS
WHERE NAME = 'Hardik';

This would produce the following result:
+	+	+	+
| ID | NAME	| SALARY	|
+	+	+	+
|	5 | Hardik	|	8500.00 |
+	+	+	+


50













SQL

16.	SQL ─ AND & OR Conjunctive Operators
The SQL AND & OR operators are used to combine multiple conditions to narrow data in an SQL statement. These two operators are called as the conjunctive operators.
These operators provide a means to make multiple comparisons with different operators in the same SQL statement.

 The AND Operator	
The AND operator allows the existence of multiple conditions in an SQL statement's WHERE clause.

Syntax
The basic syntax of the AND operator with a WHERE clause is as follows:
SELECT  column1,  column2,  columnN FROM table_name
WHERE [condition1] AND [condition2]...AND [conditionN];

You can combine N number of conditions using the AND operator. For an action to be taken by the SQL statement, whether it be a transaction or a query, all conditions separated by the AND must be TRUE.

Example
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

51

SQL



Following is an example, which would fetch the ID, Name and Salary fields from the CUSTOMERS table, where the salary is greater than 2000 and the age is less than 25 years.
SQL> SELECT ID, NAME, SALARY FROM CUSTOMERS
WHERE SALARY > 2000 AND age < 25;


This would produce the following result:
+	+	+	+
| ID | NAME	| SALARY	|
+	+	+	+
|	6  |  Komal  |	4500.00  |
|	7  |  Muffy  |  10000.00  |
+	+	+	+


The OR Operator
The OR operator is used to combine multiple conditions in an SQL statement's WHERE clause.

Syntax
The basic syntax of the OR operator with a WHERE clause is as follows:
SELECT  column1,  column2,  columnN FROM table_name
WHERE [condition1] OR [condition2]...OR [conditionN]


You can combine N number of conditions using the OR operator. For an action to be taken by the SQL statement, whether it be a transaction or query, the only any ONE of the conditions separated by the OR must be TRUE.

Example
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00|
53




|	5 | Hardik	|	27 | Bhopal
|	6  |  Komal	|	22  |  MP
|	7  |  Muffy	|	24  |  Indore
|	8500.00 |
|	4500.00  |
| 10000.00 |
+	+	+	+	+	+
The following code block has a query, which would fetch the ID, Name and Salary fields from the CUSTOMERS table, where the salary is greater than 2000 OR the age is less than 25 years.
SQL> SELECT ID, NAME, SALARY FROM CUSTOMERS
WHERE SALARY > 2000 OR age < 25;


+	+	+ 	
| ID | NAME
+	+ 	
+
| SALARY	|
+	+
+	+	+	+
This would produce the following result:






|3|kaushik|2000.00||4|Chaitali|6500.00||5|Hardik|8500.00||6|Komal|4500.00||7|Muffy|10000.00|













SQL

17.	SQL ─ UPDATE Query
The SQL UPDATE Query is used to modify the existing records in a table. You can use the WHERE clause with the UPDATE query to update the selected rows, otherwise all the rows would be affected.

Syntax
The basic syntax of the UPDATE query with a WHERE clause is as follows:
UPDATE  table_name
SET column1 = value1, column2 = value2...., columnN = valueN WHERE [condition];


You can combine N number of conditions using the AND or the OR operators.

Example
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
The following query will update the ADDRESS for a customer whose ID number is 6 in the table.
SQL> UPDATE CUSTOMERS SET  ADDRESS  =  'Pune' WHERE ID = 6;


54


SQL


Now, the CUSTOMERS table would have the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|Pune|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
If you want to modify all the ADDRESS and the SALARY column values in the CUSTOMERS table, you do not need to use the WHERE clause as the UPDATE query would be enough as shown in the following code block.
SQL> UPDATE CUSTOMERS
SET  ADDRESS  =  'Pune',  SALARY  =  1000.00;


+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS | SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+
Now, CUSTOMERS table would have the following records:






|1|Ramesh|32|Pune|1000.00||2|Khilan|25|Pune|1000.00||3|kaushik|23|Pune|1000.00||4|Chaitali|25|Pune|1000.00||5|Hardik|27|Pune|1000.00||6|Komal|22|Pune|1000.00||7|Muffy|24|Pune|1000.00|

55













SQL

18.	SQL ─ DELETE Query
The SQL DELETE Query is used to delete the existing records from a table.
You can use the WHERE clause with a DELETE query to delete the selected rows, otherwise all the records would be deleted.

Syntax
The basic syntax of the DELETE query with the WHERE clause is as follows:
DELETE  FROM  table_name WHERE [condition];

You can combine N number of conditions using AND or OR operators.

Example
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
The following code has a query, which will DELETE a customer, whose ID is 6.
SQL> DELETE FROM CUSTOMERS WHERE ID = 6;


Now, the CUSTOMERS table would have the following records.

56


SQL







|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
If you want to DELETE all the records from the CUSTOMERS table, you do not need to use the WHERE clause and the DELETE query would be as follows:
SQL> DELETE FROM CUSTOMERS;


Now, the CUSTOMERS table would not have any record.

57













SQL

19.	SQL ─ LIKE Clause
The SQL LIKE clause is used to compare a value to similar values using wildcard operators. There are two wildcards used in conjunction with the LIKE operator.
· The percent sign (%)
· The underscore (_)
The percent sign represents zero, one or multiple characters. The underscore represents a single number or character. These symbols can be used in combinations.

Syntax
The basic syntax of % and _ is as follows:
SELECT  FROM  table_name WHERE  column  LIKE  'XXXX%'

or


SELECT  FROM  table_name WHERE  column  LIKE  '%XXXX%'

or


SELECT  FROM  table_name WHERE  column  LIKE  'XXXX_'

or


SELECT  FROM  table_name WHERE  column  LIKE  '_XXXX'

or


SELECT  FROM  table_name WHERE  column  LIKE  '_XXXX_'


You can combine N number of conditions using AND or OR operators. Here, XXXX could be any numeric or string value.

58

SQL



Example
The following table has a few examples showing the WHERE part having different LIKE clause with '%' and '_' operators:

StatementDescriptionWHERE SALARY LIKE '200%'Finds any values that start with 200.WHERE SALARY LIKE '%200%'Finds any values that have 200 in any position.WHERE SALARY LIKE '_00%'Finds any values that have 00 in the second and third positions.WHERE SALARY LIKE '2_%_%'Finds any values that start with 2 and are at least 3 characters in length.WHERE SALARY LIKE '%2'Finds any values that end with 2.WHERE SALARY LIKE '_2%3'Finds any values that have a 2 in the second position and end with a 3.WHERE SALARY LIKE '2 	3'Finds any values in a five-digit number that start with 2 and end with 3.
Let us take a real example, consider the CUSTOMERS table having the records as shown below.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Following is an example, which would display all the records from the CUSTOMERS table, where the SALARY starts with 200.

60





SQL> SELECT * FROM CUSTOMERS WHERE  SALARY  LIKE  '200%';


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
|	1 | Ramesh	|	32 | Ahmedabad |	2000.00 |
|	3  |  kaushik	|	23  |  Kota	|	2000.00  |
+	+	+	+	+	+
This would produce the following result:














SQL

20.	SQL ─ TOP, LIMIT or ROWNUM Clause
The SQL TOP clause is used to fetch a TOP N number or X percent records from a table.
Note: All the databases do not support the TOP clause. For example, MySQL supports the LIMIT clause to fetch a  limited  number  of  records,  while  Oracle  uses the  ROWNUM command to fetch a limited number of records.

Syntax
The basic syntax of the TOP clause with a SELECT statement would be as follows.
SELECT TOP number|percent column_name(s) FROM table_name
WHERE [condition]

Example
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

The following query is an example on the SQL server, which would fetch the top 3 records from the CUSTOMERS table.
SQL> SELECT TOP 3 * FROM CUSTOMERS;


61


SQL


This would produce the following result:


+	+	+	+
+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
|
|
|
1 | Ramesh	|
2 | Khilan	|
3 | kaushik |
32  |  Ahmedabad  |  2000.00  |
25 | Delhi
23 | Kota
| 1500.00 |
| 2000.00 |
+	+	+	+	+	+
If you are using MySQL server, then here is an equivalent example:
SQL> SELECT * FROM CUSTOMERS LIMIT 3;


This would produce the following result:


+	+	+	+
+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
|
|
|
1 | Ramesh	|
2 | Khilan	|
3 | kaushik |
32 | Ahmedabad | 2000.00 |
25  |  Delhi
23 | Kota
|  1500.00  |
| 2000.00 |
+	+	+	+	+	+
If you are using an Oracle server, then the following code block has an equivalent example.
SQL> SELECT * FROM CUSTOMERS WHERE  ROWNUM  <=  3;


+	+	+	+
+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
|
|
|
1 | Ramesh	|
2 | Khilan	|
3 | kaushik |
32 | Ahmedabad | 2000.00 |
25 | Delhi
23 | Kota
|  1500.00  |
| 2000.00 |
+	+	+	+	+	+
This would produce the following result:


62













SQL

21.	SQL ─ ORDER BY Clause
The SQL ORDER BY clause is used to sort the data in ascending or descending order, based on one or more columns. Some databases sort the query results in an ascending order by default.

Syntax
The basic syntax of the ORDER BY clause is as follows:
SELECT column-list FROM table_name [WHERE condition]
[ORDER  BY  column1,  column2,  ..  columnN]  [ASC  |  DESC];


You can use more than one column in the ORDER BY clause. Make sure whatever column you are using to sort that column should be in the column-list.

Example
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
The following code block has an example, which would sort the result in an ascending order by the NAME and the SALARY.
SQL> SELECT * FROM CUSTOMERS ORDER  BY  NAME,  SALARY;


63


SQL


This would produce the following result:






|4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||3|kaushik|23|Kota|2000.00||2|Khilan|25|Delhi|1500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00||1|Ramesh|32|Ahmedabad|2000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
The following code block has an example, which would sort the result in the descending order by NAME.
SQL> SELECT * FROM CUSTOMERS ORDER  BY  NAME  DESC;


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
This would produce the following result:






|1|Ramesh|32|Ahmedabad|2000.00||7|Muffy|24|Indore|10000.00||6|Komal|22|MP|4500.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||5|Hardik|27|Bhopal|8500.00||4|Chaitali|25|Mumbai|6500.00|

64













SQL

22.	SQL ─ Group By
The SQL GROUP BY clause is used in collaboration with the SELECT statement to arrange identical data into groups. This GROUP BY clause follows the WHERE clause in a SELECT statement and precedes the ORDER BY clause.

Syntax
The basic syntax of a GROUP BY clause is shown in the following code block. The GROUP BY clause must follow the conditions in the WHERE clause and must precede the ORDER BY clause if one is used.
SELECT column1, column2 FROM table_name
WHERE [ conditions ] GROUP  BY  column1,  column2 ORDER BY column1, column2

Example
Consider the CUSTOMERS table is having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
If you want to know the total amount of the salary on each customer, then the GROUP BY query would be as follows.
SQL>  SELECT  NAME,  SUM(SALARY)  FROM  CUSTOMERS GROUP  BY  NAME;


65

SQL



+ 	
| NAME
+ 	
+
| SUM(SALARY) |
+	+	+
+	+	+
This would produce the following result:






|Chaitali|6500.00||Hardik|8500.00||kaushik|2000.00||Khilan|1500.00||Komal|4500.00||Muffy|10000.00||Ramesh|2000.00|

Now, let us look at a table where the CUSTOMERS table has the following records with duplicate names:






|1|Ramesh|32|Ahmedabad|2000.00||2|Ramesh|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|kaushik|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Now again, if you want to know the total amount of salary on each customer, then the GROUP BY query would be as follows:
SQL> SELECT NAME, SUM(SALARY) FROM CUSTOMERS GROUP  BY  NAME;


67



+	+	+
|  NAME	|  SUM(SALARY)  |
+	+	+
+	+	+
This would produce the following result:






|Hardik|8500.00||kaushik|8500.00||Komal|4500.00||Muffy|10000.00||Ramesh|3500.00|













SQL

23.	SQL ─ Distinct Keyword
The SQL DISTINCT keyword is used in conjunction with the SELECT statement to eliminate all the duplicate records and fetching only unique records.
There may be a situation when you have multiple duplicate records in a table. While fetching such records, it makes more sense to fetch only those unique records instead of fetching duplicate records.

Syntax
The basic syntax of DISTINCT keyword to eliminate the duplicate records is as follows:
SELECT DISTINCT column1, column2,.	columnN
FROM table_name WHERE [condition]

Example
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
First, let us see how the following SELECT query returns the duplicate salary records.
SQL> SELECT SALARY FROM CUSTOMERS ORDER  BY  SALARY;


68


SQL


This would produce the following result, where the salary (2000) is coming twice which is a duplicate record from the original table.
+	+
| SALARY	|
+	+
|	1500.00 |
|	2000.00 |
|	2000.00 |
|	4500.00 |
|	6500.00 |
|	8500.00 |
|  10000.00  |
+	+


Now, let us use the DISTINCT keyword with the above SELECT query and then see the result.
SQL> SELECT DISTINCT SALARY FROM CUSTOMERS ORDER  BY  SALARY;


This would produce the following result where we do not have any duplicate entry.
+	+
| SALARY	|
+	+
|	1500.00 |
|	2000.00 |
|	4500.00 |
|	6500.00 |
|	8500.00 |
| 10000.00 |
+	+


69













SQL

24.	SQL ─ SORTING Results
The SQL ORDER BY clause is used to sort the data in ascending or descending order, based on one or more columns. Some databases sort the query results in an ascending order by default.

Syntax
The basic syntax of the ORDER BY clause which would be used to sort the result in an ascending or descending order is as follows:
SELECT column-list FROM  table_name [WHERE condition]
[ORDER  BY  column1,  column2,  ..  columnN]  [ASC  |  DESC];


You can use more than one column in the ORDER BY clause. Make sure that whatever column you are using to sort, that column should be in the column-list.

Example
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Following is an example, which would sort the result in an ascending order by NAME and SALARY.
SQL> SELECT * FROM CUSTOMERS ORDER  BY  NAME,  SALARY;


70

SQL



+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
This would produce the following result:






|4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||3|kaushik|23|Kota|2000.00||2|Khilan|25|Delhi|1500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00||1|Ramesh|32|Ahmedabad|2000.00|

The following code block has an example, which would sort the result in a descending order by NAME.
SQL> SELECT * FROM CUSTOMERS ORDER  BY  NAME  DESC;


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
This would produce the following result:






|1|Ramesh|32|Ahmedabad|2000.00||7|Muffy|24|Indore|10000.00||6|Komal|22|MP|4500.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||5|Hardik|27|Bhopal|8500.00||4|Chaitali|25|Mumbai|6500.00|

72



To fetch the rows with their own preferred order, the SELECT query used would be as follows:
SQL> SELECT * FROM CUSTOMERS ORDER  BY  (CASE  ADDRESS WHEN  'DELHI'		THEN  1 WHEN  'BHOPAL'		THEN  2 WHEN  'KOTA'		THEN  3 WHEN  'AHMADABAD'  THEN  4 WHEN  'MP'	THEN  5
ELSE  100  END)  ASC,  ADDRESS  DESC;


This would produce the following result:






|2|Khilan|25|Delhi|1500.00||5|Hardik|27|Bhopal|8500.00||3|kaushik|23|Kota|2000.00||6|Komal|22|MP|4500.00||4|Chaitali|25|Mumbai|6500.00||7|Muffy|24|Indore|10000.00||1|Ramesh|32|Ahmedabad|2000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
This will sort the customers by ADDRESS in your ownoOrder of preference first and in a natural order for the remaining addresses. Also, the remaining Addresses will be sorted in the reverse alphabetical order.













SQL

25.	SQL ─ Constraints
Constraints are the rules enforced on the data columns of a table. These are used to limit the type of data that can go into a table. This ensures the accuracy and reliability of the data in the database.
Constraints could be either on a column level or a table level. The column level constraints are applied only to one column, whereas the table level constraints are applied to the whole table.
Following are some of the most commonly used constraints available in SQL. These constraints have already been discussed in SQL - RDBMS Concepts chapter, but it’s worth to revise them at this point.
· NOT NULL Constraint: Ensures that a column cannot have a NULL value.
· DEFAULT Constraint: Provides a default value for a column when none is specified.
· UNIQUE Constraint: Ensures that all values in a column are different.
· PRIMARY Key: Uniquely identifies each row/record in a database table.
· FOREIGN Key: Uniquely identifies row/record in any of the given database tables.
· CHECK Constraint: The CHECK constraint ensures that all the values in a column satisfies certain conditions.
· INDEX: Used to create and retrieve data from the database very quickly.
Constraints can be specified when a table is created with the CREATE TABLE statement or you can use the ALTER TABLE statement to create constraints even after the table is created.

 SQL - NOT NULL Constraint	
By default, a column can hold NULL values. If you do not want a column to have a NULL value, then you need to define such a constraint on this column specifying that NULL is now not allowed for that column.
A NULL is not the same as no data, rather, it represents unknown data.

Example
For example, the following SQL query creates a new table called CUSTOMERS and adds five columns, three of which are – ID, NAME and AGE. In this we specify not to accept NULLs:
CREATE  TABLE  CUSTOMERS(
ID	INT
NAME VARCHAR (20) AGE	INT
NOT  NULL,
NOT  NULL, NOT  NULL,


73

SQL



ADDRESS	CHAR (25) , SALARY	DECIMAL  (18,  2), PRIMARY  KEY  (ID)
);


If CUSTOMERS table has already been created, then to add a NOT NULL constraint to the SALARY column in Oracle and MySQL, you would write a query like the one that is shown in the following code block.
ALTER TABLE CUSTOMERS
MODIFY  SALARY	DECIMAL  (18,  2)  NOT  NULL;


SQL - DEFAULT Constraint
The DEFAULT constraint provides a default value to a column when the INSERT INTO statement does not provide a specific value.

Example
For example, the following SQL creates a new table called CUSTOMERS and adds five columns. Here, the SALARY column is set to 5000.00 by default, so in case the INSERT INTO statement does not provide a value for this column, then by default this column would be set to 5000.00.
CREATE  TABLE  CUSTOMERS(
ID	INT
NAME VARCHAR (20) AGE	INT
NOT NULL,
NOT  NULL, NOT  NULL,
ADDRESS	CHAR (25) ,
SALARY	DECIMAL  (18,  2)  DEFAULT  5000.00, PRIMARY  KEY  (ID)
);


If the CUSTOMERS table has already been created, then to add a DEFAULT constraint to the SALARY column, you would write a query like the one which is shown in the code block below.

MODIFY  SALARY	DECIMAL  (18,  2)  DEFAULT  5000.00;
ALTER TABLE CUSTOMERS

81



Drop Default Constraint
To drop a DEFAULT constraint, use the following SQL query.
ALTER TABLE CUSTOMERS
ALTER  COLUMN  SALARY  DROP  DEFAULT;


SQL - UNIQUE Constraint
The UNIQUE Constraint prevents two records from having identical values in a column. In the CUSTOMERS table, for example, you might want to prevent two or more people from having an identical age.

Example
For example, the following SQL query creates a new table called CUSTOMERS and adds five columns. Here, the AGE column is set to UNIQUE, so that you cannot have two records with the same age.
CREATE  TABLE  CUSTOMERS(
ID	INT
NAME VARCHAR (20) AGE	INT
NOT  NULL,
NOT  NULL,
NOT  NULL  UNIQUE,
ADDRESS	CHAR (25) ,
SALARY	DECIMAL  (18,  2), PRIMARY  KEY  (ID)
);


If the CUSTOMERS table has already been created, then to add a UNIQUE constraint to the AGE column. You would write a statement like the query that is given in the code block below.
ALTER TABLE CUSTOMERS
MODIFY  AGE  INT  NOT  NULL  UNIQUE;


You can also use the following syntax, which supports naming the constraint in multiple columns as well.
ALTER TABLE CUSTOMERS
ADD  CONSTRAINT  myUniqueConstraint  UNIQUE(AGE,  SALARY);




DROP a UNIQUE Constraint
To drop a UNIQUE constraint, use the following SQL query.
ALTER TABLE CUSTOMERS
DROP  CONSTRAINT  myUniqueConstraint;


If you are using MySQL, then you can use the following syntax:
ALTER TABLE CUSTOMERS
DROP  INDEX  myUniqueConstraint;


SQL ─ Primary Key
A primary key is a field in a table which uniquely identifies each row/record in a database table. Primary keys must contain unique values. A primary key column cannot have NULL values.
A table can have only one primary key, which may consist of single or multiple fields. When multiple fields are used as a primary key, they are called a composite key.
If a table has a primary key defined on any field(s), then you cannot have two records having the same value of that field(s).
Note: You would use these concepts while creating database tables.

Create Primary Key
Here is the syntax to define the ID attribute as a primary key in a CUSTOMERS table.



ID	INTNOTNULL,NAME VARCHAR (20)NOTNULL,AGE	INT
ADDRESS	CHAR (25)
,NOTNULL,




CREATE  TABLE  CUSTOMERS(
SALARY	DECIMAL  (18,  2),
PRIMARY  KEY  (ID)
);
To create a PRIMARY KEY constraint on the "ID" column when the CUSTOMERS table already exists, use the following SQL syntax:
ALTER  TABLE  CUSTOMER  ADD  PRIMARY  KEY  (ID);


NOTE: If you use the ALTER TABLE statement to add a primary key, the primary key column(s) should have already been declared to not contain NULL values (when the table was first created).



For defining a PRIMARY KEY constraint on multiple columns, use the SQL syntax given below.



ID	INTNOTNULL,NAME VARCHAR (20)NOTNULL,AGE	INTNOTNULL,ADDRESS	CHAR (25),




CREATE  TABLE  CUSTOMERS(
SALARY	DECIMAL  (18,  2),
PRIMARY  KEY  (ID,  NAME)
);
To create a PRIMARY KEY constraint on the "ID" and "NAMES" columns when CUSTOMERS table already exists, use the following SQL syntax.
ALTER TABLE CUSTOMERS
ADD  CONSTRAINT  PK_CUSTID  PRIMARY  KEY  (ID,  NAME);


Delete Primary Key
You can clear the primary key constraints from the table with the syntax given below.
ALTER TABLE CUSTOMERS DROP PRIMARY KEY ;


SQL ─ Foreign Key
A foreign key is a key used to link two tables together. This is sometimes also called as a referencing key.
A Foreign Key is a column or a combination of columns whose values match a Primary Key in a different table.
The relationship between 2 tables matches the Primary Key in one of the tables with a Foreign Key in the second table.
If a table has a primary key defined on any field(s), then you cannot have two records having the same value of that field(s).



Example
Consider the structure of the following two tables.
CUSTOMERS Table:



ID	INT	NOTNULL,NAME VARCHAR (20)	NOT
AGE	INT	NOTNULL,
NULL,ADDRESS	CHAR (25) ,
SALARY	DECIMAL  (18,  2),PRIMARY  KEY  (ID));
CREATE  TABLE  CUSTOMERS(
ORDERS Table
CREATE TABLE ORDERS (
ID
DATE
INT
DATETIME,
NOT  NULL,
CUSTOMER_ID  INT  references  CUSTOMERS(ID),
AMOUNT	double, PRIMARY  KEY  (ID)
);


If the ORDERS table has already been created and the foreign key has not yet been set, the use the syntax for specifying a foreign key by altering a table.
ALTER TABLE ORDERS
ADD  FOREIGN  KEY  (Customer_ID)  REFERENCES  CUSTOMERS  (ID);


DROP a FOREIGN KEY Constraint
To drop a FOREIGN KEY constraint, use the following SQL syntax.
ALTER TABLE ORDERS DROP  FOREIGN  KEY;



 SQL ─ CHECK Constraint	
The CHECK Constraint enables a condition to check the value being entered into a record. If the condition evaluates to false, the record violates the constraint and isn't entered the table.

Example
For example, the following program creates a new table called CUSTOMERS and adds five columns. Here, we add a CHECK with AGE column, so that you cannot have any CUSTOMER who is below 18 years.
CREATE  TABLE  CUSTOMERS(
ID	INT
NAME VARCHAR (20) AGE	INT
NOT  NULL,
NOT  NULL,
NOT  NULL  CHECK  (AGE  >=  18),
ADDRESS	CHAR (25) ,
SALARY	DECIMAL  (18,  2), PRIMARY  KEY  (ID)
);


If the CUSTOMERS table has already been created, then to add a CHECK constraint to AGE column, you would write a statement like the one given below.
ALTER TABLE CUSTOMERS
MODIFY  AGE  INT  NOT  NULL  CHECK  (AGE  >=  18  );


You can also use the following syntax, which supports naming the constraint in multiple columns as well:
ALTER TABLE CUSTOMERS
ADD  CONSTRAINT  myCheckConstraint  CHECK(AGE  >=  18);


DROP a CHECK Constraint
To drop a CHECK constraint, use the following SQL syntax. This syntax does not work with MySQL.
ALTER TABLE CUSTOMERS
DROP  CONSTRAINT  myCheckConstraint;



 SQL ─ INDEX Constraint	
The INDEX is used to create and retrieve data from the database very quickly. An Index can be created by using a single or a group of columns in a table. When the index is created, it is assigned a ROWID for each row before it sorts out the data.
Proper indexes are good for performance in large databases, but you need to be careful while creating an index. A selection of fields depends on what you are using in your SQL queries.

Example
CREATE  TABLE  CUSTOMERS(
SALARY	DECIMAL  (18,  2),
PRIMARY  KEY  (ID)
);
For example, the following SQL syntax creates a new table called CUSTOMERS and adds five columns:



ID	INTNOTNULL,NAME VARCHAR (20)NOTNULL,AGE	INT
ADDRESS	CHAR (25)
,NOTNULL,




Now, you can create an index on a single or multiple columns using the syntax given below.
CREATE  INDEX  index_name
ON  table_name  (  column1,  column2 	);


To create an INDEX on the AGE column, to optimize the search on customers for a specific age, follow the SQL syntax which is given below.
CREATE  INDEX  idx_age
ON CUSTOMERS ( AGE );


DROP an INDEX Constraint
To drop an INDEX constraint, use the following SQL syntax.
ALTER TABLE CUSTOMERS
DROP  INDEX  idx_age;



 Dropping Constraints	
Any constraint that you have defined can be dropped using the ALTER TABLE command with the DROP CONSTRAINT option.
For example, to drop the primary key constraint in the EMPLOYEES table, you can use the following command.
ALTER TABLE EMPLOYEES DROP CONSTRAINT EMPLOYEES_PK;

Some implementations may provide shortcuts for dropping certain constraints. For example, to drop the primary key constraint for a table in Oracle, you can use the following command.
ALTER  TABLE  EMPLOYEES  DROP  PRIMARY  KEY;


Some implementations allow you to disable constraints. Instead of permanently dropping a constraint from the database, you may want to temporarily disable the constraint and then enable it later.

 Integrity Constraints	
Integrity constraints are used to ensure accuracy and consistency of the data in a relational database. Data integrity is handled in a relational database through the concept of referential integrity.
There are many types of integrity constraints that play a role in Referential Integrity (RI). These constraints include Primary Key, Foreign Key, Unique Constraints and other constraints which are mentioned above.













SQL

26.	SQL ─ Using Joins
The SQL Joins clause is used to combine records from two or more tables in a database. A JOIN is a means for combining fields from two tables by using values common to each.
Consider the following two tables:
Table 1: CUSTOMERS Table






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+		+	+
Table 2: ORDERS Table






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|

+	+	+	+	+
|OID	| DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+	+
+	+	+	+	+
Now, let us join these two tables in our SELECT statement as shown below.
SQL> SELECT ID, NAME, AGE, AMOUNT FROM  CUSTOMERS,  ORDERS
WHERE	CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID;


82

SQL



+	+	+	+	+
| ID | NAME	| AGE | AMOUNT |
+	+	+	+	+
+	+	+	+	+
This would produce the following result.






|3|kaushik|23|3000||3|kaushik|23|1500||2|Khilan|25|1560||4|Chaitali|25|2060|

Here, it is noticeable that the join is performed in the WHERE clause. Several operators can be used to join tables, such as =, <, >, <>, <=, >=, !=, BETWEEN, LIKE, and NOT; they can all be used to join tables. However, the most common operator is the equal to symbol.
There are different types of joins available in SQL:
· INNER JOIN: returns rows when there is a match in both tables.
· LEFT JOIN: returns all rows from the left table, even if there are no matches in the right table.
· RIGHT JOIN: returns all rows from the right table, even if there are no matches in the left table.
· FULL JOIN: returns rows when there is a match in one of the tables.
· SELF JOIN: is used to join a table to itself as if the table were two tables, temporarily renaming at least one table in the SQL statement.
· CARTESIAN JOIN: returns the Cartesian product of the sets of records from the two or more joined tables.
Let us now discuss each of these joins in detail.

 SQL - INNER JOIN	
The most important and frequently used of the joins is the INNER JOIN. They are also referred to as an EQUIJOIN.
The INNER JOIN creates a new result table by combining column values of two tables (table1 and table2) based upon the join-predicate. The query compares each row of table1 with each row of table2 to find all pairs of rows which satisfy the join-predicate. When the join-predicate is satisfied, column values for each matched pair of rows of A and B are combined into a result row.





Syntax

84



The basic syntax of the INNER JOIN is as follows.
SELECT table1.column1, table2.column2... FROM table1
INNER JOIN table2
ON  table1.common_field  =  table2.common_field;


Example
Consider the following two tables.
Table 1: CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
+	+	+	+	+
|  OID  |  DATE	|  CUSTOMER_ID  |  AMOUNT  |
+	+	+	+	+
+	+	+	+	+
Table 2: ORDERS Table is as follows.






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|

SQL



Now, let us join these two tables using the INNER JOIN as follows:
SQL> SELECT	ID, NAME, AMOUNT, DATE FROM CUSTOMERS
INNER  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID;


+	+	+	+	+
| ID | NAME	| AMOUNT | DATE	|
+	+	+	+	+
+	+	+	+	+
This would produce the following result.






|3|kaushik|3000|2009-10-0800:00:00||3|kaushik|1500|2009-10-0800:00:00||2|Khilan|1560|2009-11-2000:00:00||4|Chaitali|2060|2008-05-2000:00:00|


SQL ─ LEFT JOIN

The SQL LEFT JOIN returns all rows from the left table, even if there are no matches in the right table. This means that if the ON clause matches 0 (zero) records in the right table; the join will still return a row in the result, but with NULL in each column from the right table.
This means that a left join returns all the values from the left table, plus matched values from the right table or NULL in case of no matching join predicate.

Syntax
The basic syntax of a LEFT JOIN is as follows.
SELECT table1.column1, table2.column2... FROM  table1
LEFT JOIN table2
ON table1.common_field = table2.common_field;


Here, the given condition could be any given expression based on your requirement.

94



Example
Consider the following two tables,
Table 1: CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Table 2: Orders Table is as follows.






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|

+	+	+	+	+
| OID | DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+	+
+	+	+	+	+
Now, let us join these two tables using the LEFT JOIN as follows.
SQL> SELECT	ID, NAME, AMOUNT, DATE FROM CUSTOMERS
LEFT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID;


This would produce the following result:
+	+	+	+	+
| ID | NAME	| AMOUNT | DATE	|
+	+	+	+	+





|1|Ramesh|NULL|NULL||2|Khilan|1560|2009-11-2000:00:00  ||3|kaushik|3000|2009-10-0800:00:00  ||3|kaushik|1500|2009-10-0800:00:00  ||4|Chaitali|2060|2008-05-2000:00:00  ||5|Hardik|NULL|NULL||6|Komal|NULL|NULL||7|Muffy|NULL|NULL|


+	+	+	+	+
 SQL - RIGHT JOIN	

The SQL RIGHT JOIN returns all rows from the right table, even if there are no matches in the left table. This means that if the ON clause matches 0 (zero) records in the left table; the join will still return a row in the result, but with NULL in each column from the left table.
This means that a right join returns all the values from the right table, plus matched values from the left table or NULL in case of no matching join predicate.

Syntax
The basic syntax of a RIGHT JOIN is as follow.
SELECT table1.column1, table2.column2... FROM table1
RIGHT JOIN table2
ON table1.common_field = table2.common_field;


Example
Consider the following two tables,
+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS
-+ 	
| SALARY
+	+	+	+	+ 	
+
|
+
Table 1: CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00|





|	6 | Komal
|	7  |  Muffy
|	22 | MP
|	24 | Indore
|	4500.00 |
| 10000.00 |
+	+	+	+	+	+
Table 2: ORDERS Table is as follows.






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|

+	+	+	+	+
|OID	| DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+	+
+	+	+	+	+
Now, let us join these two tables using the RIGHT JOIN as follows.
SQL> SELECT	ID, NAME, AMOUNT, DATE FROM CUSTOMERS
RIGHT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID;


+	+	+	+	+
| ID	| NAME	| AMOUNT | DATE	|
+	+	+	+	+
+	+	+	+	+
This would produce the following result:






|3|kaushik|3000|2009-10-0800:00:00||3|kaushik|1500|2009-10-0800:00:00||2|Khilan|1560|2009-11-2000:00:00||4|Chaitali|2060|2008-05-2000:00:00|


SQL ─ FULL JOIN
The SQL FULL JOIN combines the results of both left and right outer joins.
The joined table will contain all records from both the tables and fill in NULLs for missing matches on either side.



Syntax
The basic syntax of a FULL JOIN is as follows:
SELECT table1.column1, table2.column2... FROM table1
FULL JOIN table2
ON table1.common_field = table2.common_field;


Here, the given condition could be any given expression based on your requirement.

Example
Consider the following two tables.

Table 1: CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
+	+	+	+	+
|OID	| DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+		+
+	+	+	+	+
Table 2: ORDERS Table is as follows.






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|



Now, let us join these two tables using FULL JOIN as follows.
SQL> SELECT	ID, NAME, AMOUNT, DATE FROM CUSTOMERS
FULL  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID;


This would produce the following result.






|1|Ramesh|NULL|NULL||2|Khilan|1560|2009-11-2000:00:00  ||3|kaushik|3000|2009-10-0800:00:00  ||3|kaushik|1500|2009-10-0800:00:00  ||4|Chaitali|2060|2008-05-2000:00:00  ||5|Hardik|NULL|NULL||6|Komal|NULL|NULL||7|Muffy|NULL|NULL||3|kaushik|3000|2009-10-0800:00:00  ||3|kaushik|1500|2009-10-0800:00:00  ||2|Khilan|1560|2009-11-2000:00:00  ||4|Chaitali|2060|2008-05-2000:00:00  |

+	+	+	+	+
| ID	| NAME	| AMOUNT | DATE	|
+	+	+	+	+
+	+		+	+	+
If your Database does not support FULL JOIN (MySQL does not support FULL JOIN), then you can use UNION ALL clause to combine these two JOINS as shown below.
SQL> SELECT	ID, NAME, AMOUNT, DATE FROM CUSTOMERS
LEFT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID UNION ALL
SELECT	ID,  NAME,  AMOUNT,  DATE FROM CUSTOMERS
RIGHT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID



SQL ─ SELF JOIN
The SQL SELF JOIN is used to join a table to itself as if the table were two tables; temporarily renaming at least one table in the SQL statement.

Syntax
The basic syntax of SELF JOIN is as follows:
SELECT  a.column_name,  b.column_name... FROM  table1  a,  table1  b
WHERE  a.common_field  =  b.common_field;


Here, the WHERE clause could be any given expression based on your requirement.

Example
Consider the following table.
CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+
Now, let us join this table using SELF JOIN as follows:
SQL>  SELECT	a.ID,  b.NAME,  a.SALARY FROM  CUSTOMERS  a,  CUSTOMERS  b WHERE  a.SALARY  <  b.SALARY;




+	+	+	+
| ID | NAME	| SALARY	|
+	+	+	+
+	+	+	+
This would produce the following result:






|2|Ramesh|1500.00||2|kaushik|1500.00||1|Chaitali|2000.00||2|Chaitali|1500.00||3|Chaitali|2000.00||6|Chaitali|4500.00||1|Hardik|2000.00||2|Hardik|1500.00||3|Hardik|2000.00||4|Hardik|6500.00||6|Hardik|4500.00||1|Komal|2000.00||2|Komal|1500.00||3|Komal|2000.00||1|Muffy|2000.00||2|Muffy|1500.00||3|Muffy|2000.00||4|Muffy|6500.00||5|Muffy|8500.00||6|Muffy|4500.00|


SQL ─ CARTESIAN or CROSS JOIN

The CARTESIAN JOIN or CROSS JOIN returns the Cartesian product of the sets of records from two or more joined tables. Thus, it equates to an inner join where the join-condition always evaluates to either True or where the join-condition is absent from the statement.

Syntax
The basic syntax of the CARTESIAN JOIN or the CROSS JOIN is as follows:
SELECT table1.column1, table2.column2... FROM	table1, table2 [, table3 ]




Example
Consider the following two tables.

Table 1: CUSTOMERS table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Table 2: ORDERS Table is as follows:






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|

+	+	+	+	+
|OID	| DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+	+
+	+	+	+	-+
Now, let us join these two tables using INNER JOIN as follows:
SQL> SELECT	ID, NAME, AMOUNT, DATE FROM  CUSTOMERS,  ORDERS;












This would produce the following result:



+	+	+	+	+
| ID | NAME	| AMOUNT | DATE	|
+	+	+	+	+

|1|Ramesh|3000|2009-10-0800:00:00||1|Ramesh|1500|2009-10-0800:00:00||1|Ramesh|1560|2009-11-2000:00:00||1|Ramesh|2060|2008-05-2000:00:00||2|Khilan|3000|2009-10-0800:00:00||2|Khilan|1500|2009-10-0800:00:00||2|Khilan|1560|2009-11-2000:00:00||2|Khilan|2060|2008-05-2000:00:00||3|kaushik|3000|2009-10-0800:00:00||3|kaushik|1500|2009-10-0800:00:00||3|kaushik|1560|2009-11-2000:00:00||3|kaushik|2060|2008-05-2000:00:00||4|Chaitali|3000|2009-10-0800:00:00||4|Chaitali|1500|2009-10-0800:00:00||4|Chaitali|1560|2009-11-2000:00:00||4|Chaitali|2060|2008-05-2000:00:00||5|Hardik|3000|2009-10-0800:00:00||5|Hardik|1500|2009-10-0800:00:00||5|Hardik|1560|2009-11-2000:00:00||5|Hardik|2060|2008-05-2000:00:00||6|Komal|3000|2009-10-0800:00:00||6|Komal|1500|2009-10-0800:00:00||6|Komal|1560|2009-11-2000:00:00||6|Komal|2060|2008-05-2000:00:00||7|Muffy|3000|2009-10-0800:00:00||7|Muffy|1500|2009-10-0800:00:00||7|Muffy|1560|2009-11-2000:00:00||7|Muffy|2060|2008-05-2000:00:00|+	+	+	+	+














SQL

27.	SQL ─ UNIONS CLAUSE
The SQL UNION clause/operator is used to combine the results of two or more SELECT statements without returning any duplicate rows.
To use this UNION clause, each SELECT statement must have
· The same number of columns selected
· The same number of column expressions
· The same data type and
· Have them in the same order

But they need not have to be in the same length.

Syntax
The basic syntax of a UNION clause is as follows:
SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE  condition]

UNION


SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE condition]


Here, the given condition could be any given expression based on your requirement.

95

SQL



Example
Consider the following two tables.
Table 1: CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Table 2: ORDERS Table is as follows.






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|

+	+	+	+	+
|OID	| DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+	+
+	+	+	+	+
Now, let us join these two tables in our SELECT statement as follows:
SQL> SELECT	ID, NAME, AMOUNT, DATE FROM CUSTOMERS
LEFT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID UNION
SELECT	ID,  NAME,  AMOUNT,  DATE FROM CUSTOMERS
RIGHT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID;


103



+	+	+	+	+
| ID	| NAME	| AMOUNT | DATE	|
+	+	+	+	+
+	+	+	+	+
This would produce the following result:






|1|Ramesh|NULL|NULL||2|Khilan|1560|2009-11-2000:00:00  ||3|kaushik|3000|2009-10-0800:00:00  ||3|kaushik|1500|2009-10-0800:00:00  ||4|Chaitali|2060|2008-05-2000:00:00  ||5|Hardik|NULL|NULL||6|Komal|NULL|NULL||7|Muffy|NULL|NULL|


The UNION ALL Clause

The UNION ALL operator is used to combine the results of two SELECT statements including duplicate rows.
The same rules that apply to the UNION clause will apply to the UNION ALL operator.

Syntax
The basic syntax of the UNION ALL is as follows.
SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE condition]

UNION ALL


SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE condition]


Here, the given condition could be any given expression based on your requirement.






Example



Consider the following two tables,
Table 1: CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Table 2: ORDERS table is as follows.






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|

+	+	+	+	+
|OID	| DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+	+
+	+	+	+	+
Now, let us join these two tables in our SELECT statement as follows:
SQL> SELECT	ID, NAME, AMOUNT, DATE FROM CUSTOMERS
LEFT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID UNION ALL
SELECT	ID,  NAME,  AMOUNT,  DATE FROM CUSTOMERS
RIGHT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID;


This would produce the following result:




   




|1|Ramesh|NULL|NULL||2|Khilan|1560|2009-11-2000:00:00  ||3|kaushik|3000|2009-10-0800:00:00  ||3|kaushik|1500|2009-10-0800:00:00  ||4|Chaitali|2060|2008-05-2000:00:00  ||5|Hardik|NULL|NULL||6|Komal|NULL|NULL||7|Muffy|NULL|NULL||3|kaushik|3000|2009-10-0800:00:00  ||3|kaushik|1500|2009-10-0800:00:00  ||2|Khilan|1560|2009-11-2000:00:00  ||4|Chaitali|2060|2008-05-2000:00:00  |

+	+	+	+	+
| ID	| NAME	| AMOUNT | DATE	|
+	+	+	+	+
+	+	+	+	+
There are two other clauses (i.e., operators), which are like the UNION clause.
· SQL INTERSECT Clause: This is used to combine two SELECT statements, but returns rows only from the first SELECT statement that are identical to a row in the second SELECT statement.
· SQL EXCEPT Clause: This combines two SELECT statements and returns rows from the first SELECT statement that are not returned by the second SELECT statement.

 SQL ─ INTERSECT Clause	

The SQL INTERSECT clause/operator is used to combine two SELECT statements, but returns rows only from the first SELECT statement that are identical to a row in the second SELECT statement. This means INTERSECT returns only common rows returned by the two SELECT statements.
Just as with the UNION operator, the same rules apply when using the INTERSECT operator. MySQL does not support the INTERSECT operator.

Syntax
The basic syntax of INTERSECT is as follows.
SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE  condition]




INTERSECT


SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE condition]


Here, the given condition could be any given expression based on your requirement.

Example
Consider the following two tables.
Table 1: CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
+	+	+	+	+
|OID	| DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+	+
+	+	+	+	+
Table 2: ORDERS Table is as follows.






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|








Now, let us join these two tables in our SELECT statement as follows.



SQL> SELECT	ID, NAME, AMOUNT, DATE FROM CUSTOMERS
LEFT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID INTERSECT
SELECT	ID,  NAME,  AMOUNT,  DATE FROM CUSTOMERS
RIGHT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID;


+	+	+	+	+
| ID	| NAME	| AMOUNT | DATE	|
+	+	+	+	+
+	+	+	+	+
This would produce the following result.






|3|kaushik|3000|2009-10-0800:00:00||3|kaushik|1500|2009-10-0800:00:00||2|Ramesh|1560|2009-11-2000:00:00||4|kaushik|2060|2008-05-2000:00:00|


SQL ─ EXCEPT Clause
The SQL EXCEPT clause/operator is used to combine two SELECT statements and returns rows from the first SELECT statement that are not returned by the second SELECT statement. This means EXCEPT returns only rows, which are not available in the second SELECT statement.
Just as with the UNION operator, the same rules apply when using the EXCEPT operator. MySQL does not support the EXCEPT operator.

Syntax
The basic syntax of EXCEPT is as follows.
SELECT column1 [, column2 ] FROM table1 [, table2 ] [WHERE condition]

EXCEPT


SELECT column1 [, column2 ] FROM table1 [, table2 ]




[WHERE condition]

Here, the given condition could be any given expression based on your requirement.

Example
Consider the following two tables.
Table 1: CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Table 2: ORDERS table is as follows.






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|

+	+	+	+	+
|OID	| DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+	+
+	+	+	+	+
Now, let us join these two tables in our SELECT statement as shown below.
SQL> SELECT	ID, NAME, AMOUNT, DATE FROM CUSTOMERS
LEFT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID


EXCEPT




SELECT	ID,  NAME,  AMOUNT,  DATE FROM CUSTOMERS
RIGHT  JOIN  ORDERS
ON  CUSTOMERS.ID  =  ORDERS.CUSTOMER_ID;


+	+	+	+	+
| ID | NAME	| AMOUNT | DATE	|
+	+	+	+	+
+	+	+	+	+
This would produce the following result.






|1|Ramesh|NULL|NULL||5|Hardik|NULL|NULL||6|Komal|NULL|NULL||7|Muffy|NULL|NULL|













SQL

28.	SQL ─ NULL Values
The SQL NULL is the term used to represent a missing value. A NULL value in a table is a value in a field that appears to be blank.
A field with a NULL value is a field with no value. It is very important to understand that a NULL value is different than a zero value or a field that contains spaces.

Syntax
The basic syntax of NULL while creating a table.
SQL> CREATE TABLE CUSTOMERS(
ID	INT
NAME VARCHAR (20)
AGE	INT
NOT  NULL,
NOT  NULL, NOT  NULL,
ADDRESS	CHAR (25) ,
SALARY	DECIMAL  (18,  2), PRIMARY  KEY  (ID)
);


Here, NOT NULL signifies that column should always accept an explicit value of the given data type. There are two columns where we did not use NOT NULL, which means these columns could be NULL.
A field with a NULL value is the one that has been left blank during the record creation.

Example
The NULL value can cause problems when selecting data. However, because when comparing an unknown value to any other value, the result is always unknown and not included in the results. You must use the IS NULL or IS NOT NULL operators to check for a NULL value.
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
Consider the following CUSTOMERS table having the records as shown below.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00|
104


SQL



|	6 | Komal|	22 | MP|||	7  |  Muffy|	24 | Indore||




+	+	+	+	+	+
Now, following is the usage of the IS NOT NULL operator.
SQL>  SELECT	ID,  NAME,  AGE,  ADDRESS,  SALARY FROM CUSTOMERS
WHERE  SALARY  IS  NOT  NULL;


This would produce the following result:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00|

+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+
Now, following is the usage of the IS NULL operator.
SQL>  SELECT	ID,  NAME,  AGE,  ADDRESS,  SALARY FROM CUSTOMERS
WHERE  SALARY  IS  NULL;


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
This would produce the following result:






|	6 | Komal|	22 | MP|||	7  |  Muffy|	24 | Indore||

105













SQL

29.	SQL ─ Alias Syntax
You can rename a table or a column temporarily by giving another name known as Alias. The use of table aliases is to rename a table in a specific SQL statement. The renaming is a temporary change and the actual table name does not change in the database. The column aliases are used to rename a table's columns for the purpose of a particular SQL query.

Syntax
The basic syntax of a table alias is as follows.
SELECT column1, column2....
FROM table_name AS alias_name WHERE [condition];


The basic syntax of a column alias is as follows.
SELECT column_name AS alias_name FROM table_name
WHERE [condition];


Example
Consider the following two tables.
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Table 1: CUSTOMERS Table is as follows.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

106

SQL



Table 2: ORDERS Table is as follows.






|102|2009-10-0800:00:00|3|3000||100|2009-10-0800:00:00|3|1500||101|2009-11-2000:00:00|2|1560||103|2008-05-2000:00:00|4|2060|

+	+	+	+	+
|OID	| DATE	| CUSTOMER_ID | AMOUNT |
+	+	+	+	+
+	+	+	+	+
Now, the following code block shows the usage of a table alias.
SQL> SELECT C.ID, C.NAME, C.AGE, O.AMOUNT FROM  CUSTOMERS  AS  C,  ORDERS  AS  O WHERE	C.ID  =  O.CUSTOMER_ID;


This would produce the following result.






|3|kaushik|23|3000||3|kaushik|23|1500||2|Khilan|25|1560||4|Chaitali|25|2060|

+	+	+	+	+
| ID | NAME	| AGE | AMOUNT |
+	+	+	+	+
+	+	+	+	+
Following is the usage of a column alias.
SQL>  SELECT	ID  AS  CUSTOMER_ID,  NAME  AS  CUSTOMER_NAME FROM CUSTOMERS
WHERE  SALARY  IS  NOT  NULL;


108



This would produce the following result.
+	+	+
| CUSTOMER_ID | CUSTOMER_NAME  |
+	+	+
|	1 | Ramesh	|
|	2 | Khilan	|
|	3 | kaushik	|
|	4  |  Chaitali	|
|	5 | Hardik	|
|	6 | Komal	|
|	7 | Muffy	|
+	+	+














SQL

30.	SQL – Indexes
Indexes are special lookup tables that the database search engine can use to speed up data retrieval. Simply put, an index is a pointer to data in a table. An index in a database is very similar to an index in the back of a book.
For example, if you want to reference all pages in a book that discusses a certain topic, you first refer to the index, which lists all the topics alphabetically and are then referred to one or more specific page numbers.
An index helps to speed up SELECT queries and WHERE clauses, but it slows down data input, with the UPDATE and the INSERT statements. Indexes can be created or dropped with no effect on the data.
Creating an index involves the CREATE INDEX statement, which allows you to name the index, to specify the table and which column or columns to index, and to indicate whether the index is in an ascending or descending order.
Indexes can also be unique, like the UNIQUE constraint, in that the index prevents duplicate entries in the column or combination of columns on which there is an index.

The CREATE INDEX Command
The basic syntax of a CREATE INDEX is as follows.
CREATE  INDEX  index_name  ON  table_name;


Single-Column Indexes
A single-column index is created based on only one table column. The basic syntax is as follows.
CREATE  INDEX  index_name
ON table_name (column_name);


Unique Indexes
Unique indexes are used not only for performance, but also for data integrity. A unique index does not allow any duplicate values to be inserted into the table. The basic syntax is as follows.
CREATE UNIQUE INDEX index_name on table_name (column_name);


109

SQL



Composite Indexes
A composite index is an index on two or more columns of a table. Its basic syntax is as follows.
CREATE  INDEX  index_name
on  table_name  (column1,  column2);


Whether to create a single-column index or a composite index, take into consideration the column(s) that you may use very frequently in a query's WHERE clause as filter conditions.
Should there be only one column used, a single-column index should be the choice. Should there be two or more columns that are frequently used in the WHERE clause as filters, the composite index would be the best choice.

Implicit Indexes
Implicit indexes are indexes that are automatically created by the database server when an object is created. Indexes are automatically created for primary key constraints and unique constraints.

The DROP INDEX Command
An index can be dropped using SQL DROP command. Care should be taken when dropping an index because the performance may either slow down or improve.
The basic syntax is as follows:
DROP INDEX index_name;

You can check the INDEX Constraint chapter to see some actual examples on Indexes.

When should indexes be avoided?
Although indexes are intended to enhance a database's performance, there are times when they should be avoided.
The following guidelines indicate when the use of an index should be reconsidered.
· Indexes should not be used on small tables.
· Tables that have frequent, large batch updates or insert operations.
· Indexes should not be used on columns that contain a high number of NULL values.
· Columns that are frequently manipulated should not be indexed.

 SQL - INDEX Constraint	
The INDEX is used to create and retrieve data from the database very quickly. Index can be created by using a single or group of columns in a table. When the index is created, it is assigned a ROWID for each row before it sorts out the data.

111



Proper indexes are good for performance in large databases, but you need to be careful while creating an index. Selection of fields depends on what you are using in your SQL queries.

Example
CREATE  TABLE  CUSTOMERS(
SALARY	DECIMAL  (18,  2),
PRIMARY  KEY  (ID)
);
For example, the following SQL creates a new table called CUSTOMERS and adds five columns in it.



ID	INTNOTNULL,NAME VARCHAR (20)NOTNULL,AGE	INT
ADDRESS	CHAR (25)
,NOTNULL,




Now, you can create an index on a single or multiple columns using the syntax given below.
CREATE  INDEX  index_name
ON  table_name  (  column1,  column2 	);


To create an INDEX on the AGE column, to optimize the search on customers for a specific age, you can use the following SQL syntax:
CREATE  INDEX  idx_age
ON CUSTOMERS ( AGE );


DROP an INDEX Constraint
To drop an INDEX constraint, use the following SQL syntax.
ALTER TABLE CUSTOMERS
DROP  INDEX  idx_age;














SQL

31.	SQL ─ ALTER TABLE Command
The SQL ALTER TABLE command is used to add, delete or modify columns in an existing table. You should also use the ALTER TABLE command to add and drop various constraints on an existing table.

Syntax
The basic syntax of an ALTER TABLE command to add a New Column in an existing table is as follows.
ALTER  TABLE  table_name  ADD  column_name  datatype;


The basic syntax of an ALTER TABLE command to DROP COLUMN in an existing table is as follows.
ALTER  TABLE  table_name  DROP  COLUMN  column_name;


The basic syntax of an ALTER TABLE command to change the DATA TYPE of a column in a table is as follows.
ALTER  TABLE  table_name  MODIFY  COLUMN  column_name  datatype;


The basic syntax of an ALTER TABLE command to add a NOT NULL constraint to a column in a table is as follows.
ALTER  TABLE  table_name  MODIFY  column_name  datatype  NOT  NULL;


The basic syntax of an ALTER TABLE command to ADD UNIQUE CONSTRAINT to a table is as follows.
ALTER  TABLE  table_name
ADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...);


The basic syntax of an ALTER TABLE command to ADD CHECK CONSTRAINT to a table is as follows.
ALTER  TABLE  table_name
ADD  CONSTRAINT  MyUniqueConstraint  CHECK  (CONDITION);


112

SQL



The basic syntax of an ALTER TABLE command to ADD PRIMARY KEY constraint to a table is as follows.
ALTER  TABLE  table_name
ADD  CONSTRAINT  MyPrimaryKey  PRIMARY  KEY  (column1,  column2...);


The basic syntax of an ALTER TABLE command to DROP CONSTRAINT from a table is as follows.
ALTER  TABLE  table_name
DROP CONSTRAINT MyUniqueConstraint;


If you're using MySQL, the code is as follows:
ALTER  TABLE  table_name
DROP  INDEX  MyUniqueConstraint;


The basic syntax of an ALTER TABLE command to DROP PRIMARY KEY constraint from a table is as follows.
ALTER  TABLE  table_name
DROP CONSTRAINT MyPrimaryKey;


If you're using MySQL, the code is as follows:
ALTER  TABLE  table_name DROP PRIMARY KEY;


Example
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|
115



+	+	+	+	+	+


Following is the example to ADD a New Column to an existing table:
ALTER TABLE CUSTOMERS ADD SEX char(1);


Now, the CUSTOMERS table is changed and following would be output from the SELECT statement.






|1|Ramesh|32|Ahmedabad|2000.00|NULL||2|Ramesh|25|Delhi|1500.00|NULL||3|kaushik|23|Kota|2000.00|NULL||4|kaushik|25|Mumbai|6500.00|NULL||5|Hardik|27|Bhopal|8500.00|NULL||6|Komal|22|MP|4500.00|NULL||7|Muffy|24|Indore|10000.00|NULL|

+	+	+	+
+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	| SEX	|
+	+	+	+	+	+	+
+	+	+	+
+	+	+
Following is the example to DROP sex column from the existing table.
ALTER  TABLE  CUSTOMERS  DROP  SEX;


+	+	+	+
+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
+	+	+	+
+	+
Now, the CUSTOMERS table is changed and following would be the output from the SELECT statement.






|1|Ramesh|32|Ahmedabad|2000.00||2|Ramesh|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|kaushik|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|



SQL
32.
SQL - TRUNCATE TABLE Command




The SQL TRUNCATE TABLE command is used to delete complete data from an existing table.
You can also use DROP TABLE command to delete complete table but it would remove complete table structure form the database and you would need to re-create this table once again if you wish you store some data.

Syntax
The basic syntax of a TRUNCATE TABLE command is as follows.
TRUNCATE TABLE	table_name;

Example
Consider a CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Following is the example of a Truncate command.
SQL  >  TRUNCATE  TABLE  CUSTOMERS;


Now, the CUSTOMERS table is truncated and the output from SELECT statement will be as shown in the code block below:
SQL> SELECT * FROM CUSTOMERS;
Empty set (0.00 sec)


116

SQL
33.
SQL ─ Using Views




A view is nothing more than a SQL statement that is stored in the database with an associated name. A view is actually a composition of a table in the form of a predefined SQL query.
A view can contain all rows of a table or select rows from a table. A view can be created from one or many tables which depends on the written SQL query to create a view.
Views, which are a type of virtual tables allow users to do the following:
· Structure data in a way that users or classes of users find natural or intuitive.
· Restrict access to the data in such a way that a user can see and (sometimes) modify exactly what they need and no more.
· Summarize data from various tables which can be used to generate reports.

 Creating Views	
Database views are created using the CREATE VIEW statement. Views can be created from a single table, multiple tables or another view.
To create a view, a user must have the appropriate system privilege according to the specific implementation.
The basic CREATE VIEW syntax is as follows:
CREATE VIEW view_name AS SELECT column1, column2.....
FROM table_name WHERE [condition];

You can include multiple tables in your SELECT statement in a similar way as you use them in a normal SQL SELECT query.

Example
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00|
117

SQL





|	5 | Hardik	|	27 | Bhopal
|	6 | Komal	|	22 | MP
|	7  |  Muffy	|	24  |  Indore
|	8500.00 |
|	4500.00  |
| 10000.00 |
+	+	+	+	+	+
Following is an example to create a view from the CUSTOMERS table. This view would be used to have customer name and age from the CUSTOMERS table.
SQL > CREATE VIEW CUSTOMERS_VIEW AS
SELECT name, age FROM	CUSTOMERS;


Now, you can query CUSTOMERS_VIEW in a similar way as you query an actual table. Following is an example for the same.
SQL > SELECT * FROM CUSTOMERS_VIEW;


+	+	+
+	+	+
This would produce the following result.



| name| age|+ 	+ 	+| Ramesh|	32|| Khilan|	25|| kaushik|	23||  Chaitali|	25|| Hardik|	27|| Komal|	22|| Muffy|	24|


The WITH CHECK OPTION
The WITH CHECK OPTION is a CREATE VIEW statement option. The purpose of the WITH CHECK OPTION is to ensure that all UPDATE and INSERTs satisfy the condition(s) in the view definition.
If they do not satisfy the condition(s), the UPDATE or INSERT returns an error.
The following code block has an example of creating same view CUSTOMERS_VIEW with the WITH CHECK OPTION.
CREATE VIEW CUSTOMERS_VIEW AS


121



SELECT name, age FROM	CUSTOMERS WHERE age IS NOT NULL WITH CHECK OPTION;


The WITH CHECK OPTION in this case should deny the entry of any NULL values in the view's AGE column, because the view is defined by data that does not have a NULL value in the AGE column.

Updating a View
A view can be updated under certain conditions which are given below –
· The SELECT clause may not contain the keyword DISTINCT.

· The SELECT clause may not contain summary functions.

· The SELECT clause may not contain set functions.

· The SELECT clause may not contain set operators.

· The SELECT clause may not contain an ORDER BY clause.

· The FROM clause may not contain multiple tables.

· The WHERE clause may not contain subqueries.

· The query may not contain GROUP BY or HAVING.

· Calculated columns may not be updated.

· All NOT NULL columns from the base table must be included in the view in order for the INSERT query to function.

So, if a view satisfies all the above-mentioned rules then you can update that view. The following code block has an example to update the age of Ramesh.
SQL > UPDATE CUSTOMERS_VIEW SET AGE = 35
WHERE  name='Ramesh';


This would ultimately update the base table CUSTOMERS and the same would reflect in the view itself. Now, try to query the base table and the SELECT statement would produce the following result.




    




|1|Ramesh|35|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|


+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS
-+ 	
| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Inserting Rows into a View
Rows of data can be inserted into a view. The same rules that apply to the UPDATE command also apply to the INSERT command.
Here, we cannot insert rows in the CUSTOMERS_VIEW because we have not included all the NOT NULL columns in this view, otherwise you can insert rows in a view in a similar way as you insert them in a table.

Deleting Rows into a View
Rows of data can be deleted from a view. The same rules that apply to the UPDATE and INSERT commands apply to the DELETE command.
Following is an example to delete a record having AGE = 22.
SQL > DELETE FROM CUSTOMERS_VIEW WHERE  age  =  22;


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
This would ultimately delete a row from the base table CUSTOMERS and the same would reflect in the view itself. Now, try to query the base table and the SELECT statement would produce the following result.






|1|Ramesh|35|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00|




|	7  |  Muffy
|	24 | Indore
| 10000.00 |
+	+	+	+	+	+
Dropping Views
Obviously, where you have a view, you need a way to drop the view if it is no longer needed. The syntax is very simple and is given below:
DROP  VIEW  view_name;


Following is an example to drop the CUSTOMERS_VIEW from the CUSTOMERS table.
DROP VIEW CUSTOMERS_VIEW;














SQL

34.	SQL ─ Having Clause
The HAVING Clause enables you to specify conditions that filter which group results appear in the results.
The WHERE clause places conditions on the selected columns, whereas the HAVING clause places conditions on groups created by the GROUP BY clause.

Syntax
The following code block shows the position of the HAVING Clause in a query.
SELECT FROM WHERE GROUP BY HAVING ORDER BY

The HAVING clause must follow the GROUP BY clause in a query and must also precede the ORDER BY clause if used. The following code block has the syntax of the SELECT statement including the HAVING clause:
SELECT column1, column2 FROM table1, table2 WHERE [ conditions ] GROUP BY column1, column2 HAVING  [  conditions  ] ORDER BY column1, column2


Example
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
|	1 | Ramesh
|	2 | Khilan
|	3 | kaushik
|
|
|
32 | Ahmedabad |
25 | Delhi
23 | Kota
|
|
2000.00  |
1500.00 |
2000.00 |
Consider the CUSTOMERS table having the following records.


122


SQL



|4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|







+	+	+	+	+	+
Following is an example, which would display a record for a similar age count that would be more than or equal to 2.
SQL  >  SELECT  ID,  NAME,  AGE,  ADDRESS,  SALARY FROM CUSTOMERS
GROUP BY age
HAVING  COUNT(age)  >=  2;


This would produce the following result:
+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS | SALARY	|
+	+	+	+	+	+
|	2  |  Khilan  |	25  |  Delhi	|  1500.00  |
+	+	+	+	+	+


123













SQL

35.	SQL – Transactions
A transaction is a unit of work that is performed against a database. Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.
A transaction is the propagation of one or more changes to the database. For example, if you are creating a record or updating a record or deleting a record from the table, then you are performing a transaction on that table. It is important to control these transactions to ensure the data integrity and to handle database errors.
Practically, you will club many SQL queries into a group and you will execute all of them together as a part of a transaction.
 Properties of Transactions	
Transactions have the following four standard properties, usually referred to by the acronym ACID.
· Atomicity: ensures that all operations within the work unit are completed successfully. Otherwise, the transaction is aborted at the point of failure and all the previous operations are rolled back to their former state.
· Consistency: ensures that the database properly changes states upon a successfully committed transaction.
· Isolation: enables transactions to operate independently of and transparent to each other.
· Durability: ensures that the result or effect of a committed transaction persists in case of a system failure.

Transaction Control
The following commands are used to control transactions.
· COMMIT: to save the changes.
· ROLLBACK: to roll back the changes.
· SAVEPOINT: creates points within the groups of transactions in which to ROLLBACK.
· SET TRANSACTION: Places a name on a transaction.

 Transactional Control Commands	

Transactional control commands are only used with the DML Commands such as – INSERT, UPDATE and DELETE only. They cannot be used while creating tables or dropping them because these operations are automatically committed in the database.

124

SQL



The COMMIT Command
The COMMIT command is the transactional command used to save changes invoked by a transaction to the database. The COMMIT command saves all the transactions to the database since the last COMMIT or ROLLBACK command.
The syntax for the COMMIT command is as follows.
COMMIT;

Example
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Following is an example which would delete those records from the table which have age
= 25 and then COMMIT the changes in the database.
SQL> DELETE FROM CUSTOMERS WHERE  AGE  =  25;
SQL> COMMIT;


+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
|	1 | Ramesh
|	3 | kaushik
|	5 | Hardik
|
|
|
32 | Ahmedabad |
23 | Kota
27 | Bhopal
|
|
2000.00 |
2000.00 |
8500.00 |
Thus, two rows from the table would be deleted and the SELECT statement would produce the following result.


129





|	6 | Komal
|	7  |  Muffy
|	22 | MP
|	24 | Indore
|	4500.00 |
| 10000.00 |
+	+	+	+	+	+
The ROLLBACK Command
The ROLLBACK command is the transactional command used to undo transactions that have not already been saved to the database. This command can only be used to undo transactions since the last COMMIT or ROLLBACK command was issued.
The syntax for a ROLLBACK command is as follows:
ROLLBACK;

Example
Consider the CUSTOMERS table having the following records:






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Following is an example, which would delete those records from the table which have the age = 25 and then ROLLBACK the changes in the database.
SQL> DELETE FROM CUSTOMERS WHERE  AGE  =  25;
SQL>  ROLLBACK;




+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Thus, the delete operation would not impact the table and the SELECT statement would produce the following result.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

The SAVEPOINT Command
A SAVEPOINT is a point in a transaction when you can roll the transaction back to a certain point without rolling back the entire transaction.
The syntax for a SAVEPOINT command is as shown below.
SAVEPOINT SAVEPOINT_NAME;


This command serves only in the creation of a SAVEPOINT among all the transactional statements. The ROLLBACK command is used to undo a group of transactions.
The syntax for rolling back to a SAVEPOINT is as shown below.
ROLLBACK TO SAVEPOINT_NAME;


Following is an example where you plan to delete the three different records from the CUSTOMERS table. You want to create a SAVEPOINT before each delete, so that you can ROLLBACK to any SAVEPOINT at any time to return the appropriate data to its original state.

Example
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
|	1 | Ramesh
|	2 | Khilan
|	3 | kaushik
|
|
|
32 | Ahmedabad |
25 | Delhi
23 | Kota
|
|
2000.00 |
1500.00 |
2000.00 |
Consider the CUSTOMERS table having the following records.






|4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|







+	+	+	+	+	+
The following code block contains the series of operations.
SQL> SAVEPOINT SP1;
Savepoint created.
SQL> DELETE FROM CUSTOMERS WHERE ID=1;
1  row  deleted.
SQL> SAVEPOINT SP2;
Savepoint created.
SQL> DELETE FROM CUSTOMERS WHERE ID=2;
1  row  deleted.
SQL> SAVEPOINT SP3;
Savepoint created.
SQL> DELETE FROM CUSTOMERS WHERE ID=3;
1  row  deleted.


Now that the three deletions have taken place, let us assume that you have changed your mind and decided to ROLLBACK to the SAVEPOINT that you identified as SP2. Because SP2 was created after the first deletion, the last two deletions are undone:
SQL> ROLLBACK TO SP2;
Rollback complete.


SQL> SELECT * FROM CUSTOMERS;
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
Notice that only the first deletion took place since you rolled back to SP2.







|2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00|




|	6 | Komal
|	7  |  Muffy
|	22 | MP
|	24 | Indore
|	4500.00  |
| 10000.00 |
+	+	+	+	+	+
6 rows selected.
The RELEASE SAVEPOINT Command
The RELEASE SAVEPOINT command is used to remove a SAVEPOINT that you have created.
The syntax for a RELEASE SAVEPOINT command is as follows.
RELEASE SAVEPOINT SAVEPOINT_NAME;


Once a SAVEPOINT has been released, you can no longer use the ROLLBACK command to undo transactions performed since the last SAVEPOINT.

The SET TRANSACTION Command
The SET TRANSACTION command can be used to initiate a database transaction. This command is used to specify characteristics for the transaction that follows. For example, you can specify a transaction to be read only or read write.
The syntax for a SET TRANSACTION command is as follows.
SET TRANSACTION [ READ WRITE | READ ONLY ];














SQL

36.	SQL ─ Wildcard Operators
We have already discussed about the SQL LIKE operator, which is used to compare a value to similar values using the wildcard operators.
SQL supports two wildcard operators in conjunction with the LIKE operator which are explained in detail in the following table .

Wildcard OperatorsDescription
The percent sign (%)Matches one or more characters.
Note: MS Access uses the asterisk (*) wildcard character instead of the percent sign (%) wildcard character.
The underscore (_)Matches one character.
Note: MS Access uses a question mark (?) instead of the underscore (_) to match any one character.
The percent sign represents zero, one or multiple characters. The underscore represents a single number or a character. These symbols can be used in combinations.

Syntax
The basic syntax of a '%' and a '_' operator is as follows.
SELECT  FROM  table_name WHERE  column  LIKE  'XXXX%'

or


SELECT  FROM  table_name WHERE  column  LIKE  '%XXXX%'

or


SELECT  FROM  table_name WHERE  column  LIKE  'XXXX_'

or


130

SQL



SELECT  FROM  table_name WHERE  column  LIKE  '_XXXX'

or


SELECT  FROM  table_name WHERE  column  LIKE  '_XXXX_'


You can combine N number of conditions using the AND or the OR operators. Here, XXXX could be any numeric or string value.

Example
The following table has a number of examples showing the WHERE part having different LIKE clauses with '%' and '_' operators.

StatementDescriptionWHERE SALARY LIKE '200%'Finds any values that start with 200.
WHERE SALARY LIKE '%200%'
Finds any values that have 200 in any position.
WHERE SALARY LIKE '_00%'Finds any values that have 00 in the second and third positions.
WHERE SALARY LIKE '2_%_%'Finds any values that start with 2 and are at least 3 characters in length.WHERE SALARY LIKE '%2'Finds any values that end with 2.
WHERE SALARY LIKE '_2%3'Finds any values that have a 2 in the second position and end with a 3.
WHERE SALARY LIKE '2 	3'Finds any values in a five-digit number that start with 2 and end with 3.
132



Let us take a real example, consider the CUSTOMERS table having the following records.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+
The following code block is an example, which would display all the records from the CUSTOMERS table where the SALARY starts with 200.
SQL> SELECT * FROM CUSTOMERS WHERE  SALARY  LIKE  '200%';


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
|	1 | Ramesh	|	32 | Ahmedabad |	2000.00 |
|	3 | kaushik	|	23 | Kota	|	2000.00 |
+	+	+	+	+	+
This would produce the following result.














SQL

37.	SQL ─ Date Functions
The following table has a list of all the important Date and Time related functions available through SQL. There are various other functions supported by your RDBMS. The given list is based on MySQL RDBMS.

NameDescriptionADDDATE()Adds datesADDTIME()Adds timeCONVERT_TZ()Converts from one timezone to anotherCURDATE()Returns the current dateCURRENT_DATE(), CURRENT_DATE
Synonyms for CURDATE()CURRENT_TIME(), CURRENT_TIME
Synonyms for CURTIME()CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP
Synonyms for NOW()CURTIME()Returns the current timeDATE_ADD()Adds two datesDATE_FORMAT()Formats date as specifiedDATE_SUB()Subtracts two datesDATE()Extracts the date part of a date or datetime expressionDATEDIFF()Subtracts two datesDAY()Synonym for DAYOFMONTH()
133

SQL



DAYNAME()Returns the name of the weekdayDAYOFMONTH()Returns the day of the month (1-31)DAYOFWEEK()Returns the weekday index of the argumentDAYOFYEAR()Returns the day of the year (1-366)EXTRACTExtracts part of a dateFROM_DAYS()Converts a day number to a dateFROM_UNIXTIME()Formats date as a UNIX timestampHOUR()Extracts the hourLAST_DAYReturns the last day of the month for the argumentLOCALTIME(), LOCALTIMESynonym for NOW()LOCALTIMESTAMP, LOCALTIMESTAMP()
Synonym for NOW()MAKEDATE()Creates a date from the year and day of yearMAKETIMEMAKETIME()MICROSECOND()Returns the microseconds from argumentMINUTE()Returns the minute from the argumentMONTH()Return the month from the date passedMONTHNAME()Returns the name of the monthNOW()Returns the current date and timePERIOD_ADD()Adds a period to a year-monthPERIOD_DIFF()Returns the number of months between periods
154



QUARTER()Returns the quarter from a date argumentSEC_TO_TIME()Converts seconds to 'HH:MM:SS' formatSECOND()Returns the second (0-59)STR_TO_DATE()Converts a string to a date
SUBDATE()When invoked with three arguments a synonym for DATE_SUB()SUBTIME()Subtracts timesSYSDATE()Returns the time at which the function executesTIME_FORMAT()Formats as timeTIME_TO_SEC()Returns the argument converted to secondsTIME()Extracts the time portion of the expression passedTIMEDIFF()Subtracts time
TIMESTAMP()With a single argument this function returns the date or datetime expression. With two arguments, the sum of the argumentsTIMESTAMPADD()Adds an interval to a datetime expressionTIMESTAMPDIFF()Subtracts an interval from a datetime expressionTO_DAYS()Returns the date argument converted to daysUNIX_TIMESTAMP()Returns a UNIX timestampUTC_DATE()Returns the current UTC dateUTC_TIME()Returns the current UTC timeUTC_TIMESTAMP()Returns the current UTC date and time


WEEK()Returns the week numberWEEKDAY()Returns the weekday indexWEEKOFYEAR()Returns the calendar week of the date (1-53)YEAR()Returns the yearYEARWEEK()Returns the year and week
ADDDATE(date,INTERVAL expr unit), ADDDATE(expr,days)
When invoked with the INTERVAL form of the second argument, ADDDATE() is a synonym for DATE_ADD(). The related function SUBDATE() is a synonym for DATE_SUB(). For information on the INTERVAL unit argument, see the discussion for DATE_ADD().
mysql>  SELECT  DATE_ADD('1998-01-02',  INTERVAL  31  DAY);
+	+
|  DATE_ADD('1998-01-02',  INTERVAL  31  DAY)	|
+	+
| 1998-02-02	|
+	+
1 row in set (0.00 sec)


mysql>  SELECT  ADDDATE('1998-01-02',  INTERVAL  31  DAY);
+	+
|  ADDDATE('1998-01-02',  INTERVAL  31  DAY)	|
+	+
| 1998-02-02	|
+	+
1 row in set (0.00 sec)




When invoked with the days form of the second argument, MySQL treats it as an integer number of days to be added to expr.
mysql>  SELECT  ADDDATE('1998-01-02',  31);
+	+
|  DATE_ADD('1998-01-02',  INTERVAL  31  DAY)	|
+	+
| 1998-02-02	|
+	+
1 row in set (0.00 sec)


ADDTIME(expr1,expr2)
ADDTIME() adds expr2 to expr1 and returns the result. The expr1 is a time or datetime expression, while the expr2 is a time expression.
mysql>  SELECT  ADDTIME('1997-12-31  23:59:59.999999','1  1:1:1.000002');
+	+
|  DATE_ADD('1997-12-31  23:59:59.999999','1  1:1:1.000002')  |
+	+
|  1998-01-02  01:01:01.000001	|
+	+
1 row in set (0.00 sec)


CONVERT_TZ(dt,from_tz,to_tz)
This converts a datetime value dt from the time zone given by from_tz to the time zone given by to_tz and returns the resulting value. This function returns NULL if the arguments are invalid.
mysql>  SELECT  CONVERT_TZ('2004-01-01  12:00:00','GMT','MET');
+	+
|  CONVERT_TZ('2004-01-01  12:00:00','GMT','MET')	|
+	+
|  2004-01-01  13:00:00	|
+	+
1 row in set (0.00 sec)


mysql>  SELECT  CONVERT_TZ('2004-01-01  12:00:00','+00:00','+10:00');
+	+
|  CONVERT_TZ('2004-01-01  12:00:00','+00:00','+10:00')	|




+	+




|  2004-01-01  22:00:00
|
+	+
1 row in set (0.00 sec)
CURDATE()
Returns the current date as a value in 'YYYY-MM-DD' or YYYYMMDD format, depending on whether the function is used in a string or in a numeric context.
mysql>  SELECT  CURDATE();
+	+
| CURDATE()	|
+	+
| 1997-12-15	|
+	+
1 row in set (0.00 sec)


mysql>  SELECT  CURDATE()  +  0;
+	+
| CURDATE() + 0	|
+	+
| 19971215	|
+	+
1  row  in  set  (0.00  sec)


CURRENT_DATE and CURRENT_DATE()
CURRENT_DATE and CURRENT_DATE() are synonyms for CURDATE()

CURTIME()
Returns the current time as a value in 'HH:MM:SS' or HHMMSS format, depending on whether the function is used in a string or in a numeric context. The value is expressed in the current time zone.
mysql>  SELECT  CURTIME();
+	+
| CURTIME()	|
+	+
| 23:50:26	|




+	+
1 row in set (0.00 sec)


mysql> SELECT CURTIME() + 0;
+	+
| CURTIME() + 0	|
+	+
| 235026	|
+	+
1 row in set (0.00 sec)


CURRENT_TIME and CURRENT_TIME()
CURRENT_TIME and CURRENT_TIME() are synonyms for CURTIME().

CURRENT_TIMESTAMP and CURRENT_TIMESTAMP()
CURRENT_TIMESTAMP and CURRENT_TIMESTAMP() are synonyms for NOW().

DATE(expr)
Extracts the date part of the date or datetime expression expr.
mysql>  SELECT  DATE('2003-12-31  01:02:03');
+	+
|  DATE('2003-12-31  01:02:03')	|
+	+
|	2003-12-31	|
+	+
1 row in set (0.00 sec)


DATEDIFF(expr1,expr2)
DATEDIFF() returns expr1 . expr2 expressed as a value in days from one date to the other. Both expr1 and expr2 are date or date-and-time expressions. Only the date parts of the values are used in the calculation.
mysql>  SELECT  DATEDIFF('1997-12-31  23:59:59','1997-12-30');
+	+
|  DATEDIFF('1997-12-31  23:59:59','1997-12-30')	|
+	+
| 1	|
+	+




1 row in set (0.00 sec)


DATE_ADD(date,INTERVAL expr unit), DATE_SUB(date,INTERVAL expr unit)
These functions perform date arithmetic. The Date is a DATETIME or DATE value specifying the starting date. The expr is an expression specifying the interval value to be added or subtracted from the starting date. The expr is a string; it may start with a '-' for negative intervals.
A Unit is a keyword indicating the units in which the expression should be interpreted. The INTERVAL keyword and the unit specifier are not case sensitive.
The following table shows the expected form of the expr argument for each unit value.

unit ValueExpectedexprFormatMICROSECONDMICROSECONDSSECONDSECONDSMINUTEMINUTESHOURHOURSDAYDAYSWEEKWEEKSMONTHMONTHSQUARTERQUARTERSYEARYEARSSECOND_MICROSECOND'SECONDS.MICROSECONDS'MINUTE_MICROSECOND'MINUTES.MICROSECONDS'MINUTE_SECOND'MINUTES:SECONDS'HOUR_MICROSECOND'HOURS.MICROSECONDS'


HOUR_SECOND'HOURS:MINUTES:SECONDS'HOUR_MINUTE'HOURS:MINUTES'DAY_MICROSECOND'DAYS.MICROSECONDS'DAY_SECOND'DAYS HOURS:MINUTES:SECONDS'DAY_MINUTE'DAYS HOURS:MINUTES'DAY_HOUR'DAYS HOURS'YEAR_MONTH'YEARS-MONTHS'
The values QUARTER and WEEK are available from the MySQL 5.0.0 version.
mysql>  SELECT  DATE_ADD('1997-12-31  23:59:59',
->  INTERVAL  '1:1'  MINUTE_SECOND);
+	+
|  DATE_ADD('1997-12-31  23:59:59',  INTERVAL...	|
+	+
|  1998-01-01  00:01:00	|
+	+
1 row in set (0.00 sec)


mysql>  SELECT  DATE_ADD('1999-01-01',  INTERVAL  1  HOUR);
+	+
|  DATE_ADD('1999-01-01',  INTERVAL  1  HOUR)	|
+	+
|  1999-01-01  01:00:00	|
+	+
1 row in set (0.00 sec)






DATE_FORMAT(date,format)
This command formats the date value as per the format string. The following specifiers may be used in the format string. The '%' character is required before the format specifier characters.

SpecifierDescription%aAbbreviated weekday name (Sun..Sat)%bAbbreviated month name (Jan..Dec)%cMonth, numeric (0..12)%DDay of the month with English suffix (0th, 1st, 2nd, 3rd, .)%dDay of the month, numeric (00..31)%eDay of the month, numeric (0..31)%fMicroseconds (000000..999999)%HHour (00..23)%hHour (01..12)%IHour (01..12)%iMinutes, numeric (00..59)%jDay of year (001..366)%kHour (0..23)%lHour (1..12)%MMonth name (January..December)


%mMonth, numeric (00..12)%pAM or PM%rTime, 12-hour (hh:mm:ss followed by AM or PM)%SSeconds (00..59)%sSeconds (00..59)%TTime, 24-hour (hh:mm:ss)%UWeek (00..53), where Sunday is the first day of the week%uWeek (00..53), where Monday is the first day of the week
%VWeek (01..53), where Sunday is the first day of the week; used with
%X
%vWeek (01..53), where Monday is the first day of the week; used with
%x%WWeekday name (Sunday..Saturday)%wDay of the week (0=Sunday..6=Saturday)
%XYear for the week where Sunday is the first day of the week, numeric, four digits; used with %V
%xYear for the week, where Monday is the first day of the week, numeric, four digits; used with %v%YYear, numeric, four digits%yYear, numeric (two digits)%%A literal .%. character


%xx, for any.x. not listed above


mysql>  SELECT  DATE_FORMAT('1997-10-04  22:23:00',  '%W  %M  %Y');
+	+
|  DATE_FORMAT('1997-10-04  22:23:00',  '%W  %M  %Y')	|
+	+
| Saturday October 1997	|
+	+
1 row in set (0.00 sec)


mysql>  SELECT  DATE_FORMAT('1997-10-04  22:23:00'
->  '%H  %k  %I  %r  %T  %S  %w');
+	+
|  DATE_FORMAT('1997-10-04  22:23:00.......	|
+	+
|	22 22 10 10:23:00 PM 22:23:00 00 6	|
+	+
1 row in set (0.00 sec)


DATE_SUB(date,INTERVAL expr unit)
This is similar to the DATE_ADD() function.

DAY(date)
The DAY() is a synonym for the DAYOFMONTH() function.

DAYNAME(date)
Returns the name of the weekday for date.
mysql>  SELECT  DAYNAME('1998-02-05');
+	+
|  DAYNAME('1998-02-05')	|
+	+
| Thursday	|
+	+
1 row in set (0.00 sec)




DAYOFMONTH(date)
Returns the day of the month for date, in the range 0 to 31.
mysql>  SELECT  DAYOFMONTH('1998-02-03');
+	+
|  DAYOFMONTH('1998-02-03')	|
+	+
| 3	|
+	+
1 row in set (0.00 sec)


DAYOFWEEK(date)
Returns the weekday index for date (1 = Sunday, 2 = Monday, ., 7 = Saturday). These index values correspond to the ODBC standard.
mysql>  SELECT  DAYOFWEEK('1998-02-03');
+	+
|DAYOFWEEK('1998-02-03')	|
+	+
| 3	|
+	+
1 row in set (0.00 sec)


DAYOFYEAR(date)
Returns the day of the year for date, in the range 1 to 366.
mysql>  SELECT  DAYOFYEAR('1998-02-03');
+	+
|  DAYOFYEAR('1998-02-03')	|
+	+
| 34	|
+	+
1 row in set (0.00 sec)








EXTRACT(unit FROM date)



The EXTRACT() function uses the same kinds of unit specifiers as DATE_ADD() or DATE_SUB(), but extracts parts from the date rather than performing date arithmetic.
mysql>  SELECT  EXTRACT(YEAR  FROM  '1999-07-02');
+	+
|  EXTRACT(YEAR  FROM  '1999-07-02')	|
+	+
| 1999	|
+	+
1 row in set (0.00 sec)


mysql>  SELECT  EXTRACT(YEAR_MONTH  FROM  '1999-07-02  01:02:03');
+	+
|  EXTRACT(YEAR_MONTH  FROM  '1999-07-02  01:02:03')	|
+	+
| 199907	|
+	+
1 row in set (0.00 sec)


FROM_DAYS(N)
Given a day number N, returns a DATE value.
mysql>  SELECT  FROM_DAYS(729669);
+	+
|  FROM_DAYS(729669)	|
+	+
| 1997-10-07	|
+	+
1 row in set (0.00 sec)


Note: Use FROM_DAYS() with caution on old dates. It is not intended for use with values that precede the advent of the Gregorian calendar (1582).
FROM_UNIXTIME(unix_timestamp) FROM_UNIXTIME(unix_timestamp,format)
Returns a representation of the unix_timestamp argument as a value in 'YYYY-MM-DD HH:MM:SS or YYYYMMDDHHMMSS format, depending on whether the function is used in a string or in a numeric context. The value is expressed in the current time zone. The unix_timestamp argument is an internal timestamp values, which are produced by the UNIX_TIMESTAMP() function.



If the format is given, the result is formatted according to the format string, which is used in the same way as is listed in the entry for the DATE_FORMAT() function.
mysql>  SELECT  FROM_UNIXTIME(875996580);
+	+
| FROM_UNIXTIME(875996580)	|
+	+
|  1997-10-04  22:23:00	|
+	+
1 row in set (0.00 sec)


HOUR(time)
Returns the hour for time. The range of the return value is 0 to 23 for time-of-day values. However, the range of TIME values actually is much larger, so HOUR can return values greater than 23.
mysql>  SELECT  HOUR('10:05:03');
+	+
| HOUR('10:05:03')	|
+	+
| 10	|
+	+
1 row in set (0.00 sec)


LAST_DAY(date)
Takes a date or datetime value and returns the corresponding value for the last day of the month. Returns NULL if the argument is invalid.
mysql>  SELECT  LAST_DAY('2003-02-05');
+	+
|  LAST_DAY('2003-02-05')	|
+	+
| 2003-02-28	|
+	+
1 row in set (0.00 sec)





LOCALTIME and LOCALTIME()
LOCALTIME and LOCALTIME() are synonyms for NOW().



LOCALTIMESTAMP and LOCALTIMESTAMP()
LOCALTIMESTAMP and LOCALTIMESTAMP() are synonyms for NOW().

MAKEDATE(year,dayofyear)
Returns a date, given year and day-of-year values. The dayofyear value must be greater than 0 or the result will be NULL.
mysql>  SELECT  MAKEDATE(2001,31),  MAKEDATE(2001,32);
+	+
|  MAKEDATE(2001,31),  MAKEDATE(2001,32)	|
+	+
|  '2001-01-31',  '2001-02-01'	|
+	+
1 row in set (0.00 sec)


MAKETIME(hour,minute,second)
Returns a time value calculated from the hour, minute and second arguments.
mysql> SELECT MAKETIME(12,15,30);
+	+
| MAKETIME(12,15,30)	|
+	+
| '12:15:30'	|
+	+
1 row in set (0.00 sec)


MICROSECOND(expr)
Returns the microseconds from the time or datetime expression (expr) as a number in the range from 0 to 999999.
mysql>  SELECT  MICROSECOND('12:00:00.123456');
+	+
|  MICROSECOND('12:00:00.123456')	|
+	+
| 123456	|
+	+
1  row  in  set  (0.00  sec)


MINUTE(time)
Returns the minute for time, in the range 0 to 59.



mysql>  SELECT  MINUTE('98-02-03  10:05:03');
+	+
|  MINUTE('98-02-03  10:05:03')	|
+	+
| 5	|
+	+
1 row in set (0.00 sec)


MONTH(date)
Returns the month for date, in the range 0 to 12.
mysql>  SELECT  MONTH('1998-02-03')
+	+
|  MONTH('1998-02-03')	|
+	+
| 2	|
+	+
1 row in set (0.00 sec)


MONTHNAME(date)
Returns the full name of the month for a date.
mysql>  SELECT  MONTHNAME('1998-02-05');
+	+
|  MONTHNAME('1998-02-05')	|
+	+
| February	|
+	+
1  row  in  set  (0.00  sec)


NOW()
Returns the current date and time as a value in 'YYYY-MM-DD HH:MM:SS' or YYYYMMDDHHMMSS format, depending on whether the function is used in a string or numeric context. This value is expressed in the current time zone.

mysql>  SELECT  NOW();
+	+
| NOW()	|




+	+
|  1997-12-15  23:50:26	|
+	+
1 row in set (0.00 sec)


PERIOD_ADD(P,N)
Adds N months to a period P (in the format YYMM or YYYYMM). Returns a value in the format YYYYMM.
Note that the period argument P is not a date value.
mysql>  SELECT  PERIOD_ADD(9801,2);
+	+
| PERIOD_ADD(9801,2)	|
+	+
| 199803	|
+	+
1 row in set (0.00 sec)


PERIOD_DIFF(P1,P2)
Returns the number of months between periods P1 and P2. These periods P1 and P2 should be in the format YYMM or YYYYMM.
Note that the period arguments P1 and P2 are not date values.
mysql> SELECT PERIOD_DIFF(9802,199703);
+	+
| PERIOD_DIFF(9802,199703)	|
+	+
| 11	|
+	+
1 row in set (0.00 sec)








QUARTER(date)
mysql>  SELECT  QUARTER('98-04-01');
Returns the quarter of the year for date, in the range 1 to 4.



+	+
|  QUARTER('98-04-01')	|
+	+
| 2	|
+	+
1 row in set (0.00 sec)


SECOND(time)
Returns the second for time, in the range 0 to 59.
mysql>  SELECT  SECOND('10:05:03');
+	+
|  SECOND('10:05:03')	|
+	+
| 3	|
+	+
1 row in set (0.00 sec)


SEC_TO_TIME(seconds)
Returns the seconds argument, converted to hours, minutes and seconds, as a value in 'HH:MM:SS' or HHMMSS format, depending on whether the function is used in a string or numeric context.
mysql>  SELECT  SEC_TO_TIME(2378);
+	+
| SEC_TO_TIME(2378)	|
+	+
| 00:39:38	|
+	+
1 row in set (0.00 sec)







STR_TO_DATE(str,format)
This is the inverse of the DATE_FORMAT() function. It takes a string str and a format string format. The STR_TO_DATE() function returns a DATETIME value if the format string contains both date and time parts. Else, it returns a DATE or TIME value if the string contains only date or time parts.



mysql>  SELECT  STR_TO_DATE('04/31/2004',  '%m/%d/%Y');
+	+
|  STR_TO_DATE('04/31/2004',  '%m/%d/%Y')	|
+	+
| 2004-04-31	|
+	+
1 row in set (0.00 sec)


SUBDATE(date,INTERVAL expr unit) and SUBDATE(expr,days)
When invoked with the INTERVAL form of the second argument, SUBDATE() is a synonym for DATE_SUB(). For information on the INTERVAL unit argument, see the discussion for DATE_ADD().
mysql>  SELECT  DATE_SUB('1998-01-02',  INTERVAL  31  DAY);
+	+
|  DATE_SUB('1998-01-02',  INTERVAL  31  DAY)	|
+	+
| 1997-12-02	|
+	+
1 row in set (0.00 sec)


mysql>  SELECT  SUBDATE('1998-01-02',  INTERVAL  31  DAY);
+	+
|  SUBDATE('1998-01-02',  INTERVAL  31  DAY)	|
+	+
| 1997-12-02	|
+	+
1 row in set (0.00 sec)








SUBTIME(expr1,expr2)
The SUBTIME() function returns expr1 . expr2 expressed as a value in the same format as expr1. The expr1 value is a time or a datetime expression, while the expr2 value is a time expression.
mysql>  SELECT  SUBTIME('1997-12-31  23:59:59.999999',




->  '1  1:1:1.000002');
+	+
|  SUBTIME('1997-12-31  23:59:59.999999'...	|
+	+
|  1997-12-30  22:58:58.999997	|
+		+
1 row in set (0.00 sec)


SYSDATE()
Returns the current date and time as a value in 'YYYY-MM-DD HH:MM:SS' or YYYYMMDDHHMMSS format, depending on whether the function is used in a string or in a numeric context.
mysql>  SELECT  SYSDATE();
+	+
| SYSDATE()	|
+	+
|  2006-04-12  13:47:44	|
+	+
1 row in set (0.00 sec)


TIME(expr)
Extracts the time part of the time or datetime expression expr and returns it as a string.
mysql>  SELECT  TIME('2003-12-31  01:02:03');
+	+
|  TIME('2003-12-31  01:02:03')	|
+	+
| 01:02:03	|
+	+
1 row in set (0.00 sec)





TIMEDIFF(expr1,expr2)
mysql>  SELECT  TIMEDIFF('1997-12-31  23:59:59.000001',
The TIMEDIFF() function returns expr1 . expr2 expressed as a time value. These expr1 and expr2 values are time or date-and-time expressions, but both must be of the same type.

SQL



->  '1997-12-30  01:01:01.000002');
+	+
|  TIMEDIFF('1997-12-31  23:59:59.000001'.....	|
+	+
|	46:58:57.999999	|
+	+
1 row in set (0.00 sec)


TIMESTAMP(expr), TIMESTAMP(expr1,expr2)
With a single argument, this function returns the date or datetime expression expr as a datetime value. With two arguments, it adds the time expression expr2 to the date or datetime expression expr1 and returns the result as a datetime value.
mysql>  SELECT  TIMESTAMP('2003-12-31');
+	+
|  TIMESTAMP('2003-12-31')	|
+	+
|  2003-12-31  00:00:00	|
+	+
1  row  in  set  (0.00  sec)


TIMESTAMPADD(unit,interval,datetime_expr)
This function adds the integer expression interval to the date or datetime expression – datetime_expr. The unit for interval is given by the unit argument, which should be one of the following values –

· FRAC_SECOND
· SECOND, MINUTE
· HOUR, DAY
· WEEK
· MONTH
· QUARTER or
· YEAR

The unit value may be specified using one of the keywords as shown or with a prefix of SQL_TSI_.
For example, DAY and SQL_TSI_DAY both are legal.
mysql>  SELECT  TIMESTAMPADD(MINUTE,1,'2003-01-02');
+	+
|  TIMESTAMPADD(MINUTE,1,'2003-01-02')	|


161



+	+
|  2003-01-02  00:01:00	|
+	+
1 row in set (0.00 sec)


TIMESTAMPDIFF(unit,datetime_expr1,datetime_expr2)
mysql>  SELECT  TIMESTAMPDIFF(MONTH,'2003-02-01','2003-05-01');
+	+
|  TIMESTAMPDIFF(MONTH,'2003-02-01','2003-05-01')	|
+	+
| 3
+ 	
1 row in set (0.00 sec)
|
 	
+
Returns the integer difference between the date or datetime expressions datetime_expr1 and datetime_expr2. The unit for the result is given by the unit argument. The legal values for the unit are the same as those listed in the description of the TIMESTAMPADD() function.


TIME_FORMAT(time,format)
This function is used like the DATE_FORMAT() function, but the format string may contain format specifiers only for hours, minutes and seconds.
If the time value contains an hour part that is greater than 23, the %H and %k hour format specifiers produce a value larger than the usual range of 0 to 23. The other hour format specifiers produce the hour value modulo 12.
mysql>  SELECT  TIME_FORMAT('100:00:00',  '%H  %k  %h  %I  %l');
+	+
|  TIME_FORMAT('100:00:00',  '%H  %k  %h  %I  %l')	|
+	+
| 100 100 04  04 4	|
+	+
1 row in set (0.00 sec)





TIME_TO_SEC(time)
Returns the time argument converted to seconds.
mysql>  SELECT  TIME_TO_SEC('22:23:00');




+	+
| TIME_TO_SEC('22:23:00')	|
+	+
| 80580	|
+	+
1 row in set (0.00 sec)


TO_DAYS(date)
Given a date, returns a day number (the number of days since year 0).
mysql> SELECT TO_DAYS(950501);
+	+
| TO_DAYS(950501)	|
+	+
| 728779	|
+	+
1 row in set (0.00 sec)


UNIX_TIMESTAMP(), UNIX_TIMESTAMP(date)
If called with no argument, this function returns a Unix timestamp (seconds since '1970-
mysql>  SELECT  UNIX_TIMESTAMP();
+	+
| UNIX_TIMESTAMP()	|
+	+
| 882226357	|
+	+
1 row in set (0.00 sec)
mysql>  SELECT  UNIX_TIMESTAMP('1997-10-04  22:23:00');
+	+
|  UNIX_TIMESTAMP('1997-10-04  22:23:00')	|
+	+
| 875996580
|
%0-01 00:00:00' UTC) as an unsigned integer. If UNIX_TIMESTAMP() is called with a date argument, it returns the value of the argument as seconds, since '1970-01-01 00:00:00' UTC. date may be a DATE string, a DATETIME string, a TIMESTAMP, or a number in the format YYMMDD or YYYYMMDD.




+	+
1  row  in  set  (0.00  sec)


UTC_DATE, UTC_DATE()
Returns the current UTC date as a value in 'YYYY-MM-DD' or YYYYMMDD format, depending on whether the function is used in a string or numeric context.
mysql>  SELECT  UTC_DATE(),  UTC_DATE()  +  0;
+		+
|  UTC_DATE(),  UTC_DATE()  +  0	|
+	+
|  2003-08-14,  20030814	|
+	+
1 row in set (0.00 sec)


UTC_TIME, UTC_TIME()
Returns the current UTC time as a value in 'HH:MM:SS' or HHMMSS format, depending on whether the function is used in a string or numeric context.
mysql>  SELECT  UTC_TIME(),  UTC_TIME()  +  0;
+	+
| UTC_TIME(), UTC_TIME() + 0	|
+	+
| 18:07:53, 180753	|
+	+
1 row in set (0.00 sec)


UTC_TIMESTAMP, UTC_TIMESTAMP()
Returns the current UTC date and time as a value in 'YYYY-MM-DD HH:MM:SS' or in a YYYYMMDDHHMMSS format, depending on whether the function is used in a string or in a numeric context.







mysql>  SELECT  UTC_TIMESTAMP(),  UTC_TIMESTAMP()  +  0;
+	+
| UTC_TIMESTAMP(), UTC_TIMESTAMP() + 0	|




+	+
|  2003-08-14  18:08:04,  20030814180804	|
+	+
1 row in set (0.00 sec)


WEEK(date[,mode])
This function returns the week number for date. The two-argument form of WEEK() allows you to specify whether the week starts on a Sunday or a Monday and whether the return value should be in the range from 0 to 53 or from 1 to 53. If the mode argument is omitted, the value of the default_week_format system variable is used

ModeFirst Day of weekRangeWeek 1 is the first week.0Sunday0-53with a Sunday in this year1Monday0-53with more than 3 days this year2Sunday1-53with a Sunday in this year3Monday1-53with more than 3 days this year4Sunday0-53with more than 3 days this year5Monday0-53with a Monday in this year6Sunday1-53with more than 3 days this year7Monday1-53with a Monday in this yearmysql>  SELECT  WEEK('1998-02-20');
+	+
|  WEEK('1998-02-20')	|
+	+
| 7	|
+	+
1 row in set (0.00 sec)


WEEKDAY(date)
Returns the weekday index for date (0 = Monday, 1 = Tuesday, . 6 = Sunday).



mysql>  SELECT  WEEKDAY('1998-02-03  22:23:00');
+	+
|  WEEKDAY('1998-02-03  22:23:00')	|
+	+
| 1	|
+	+
1 row in set (0.00 sec)


WEEKOFYEAR(date)
Returns the calendar week of the date as a number in the range from 1 to 53. WEEKOFYEAR() is a compatibility function that is equivalent to WEEK(date,3).
mysql>  SELECT  WEEKOFYEAR('1998-02-20');
+	+
|  WEEKOFYEAR('1998-02-20')	|
+	+
| 8	|
+	+
1 row in set (0.00 sec)


YEAR(date)
Returns the year for date, in the range 1000 to 9999 or 0 for the .zero. date.
mysql>  SELECT  YEAR('98-02-03');
+	+
|  YEAR('98-02-03')	|
+	+
| 1998	|
+	+
1 row in set (0.00 sec)


YEARWEEK(date), YEARWEEK(date,mode)
Returns the year and the week for a date. The mode argument works exactly like the mode argument to the WEEK() function. The year in the result may be different from the year in the date argument for the first and the last week of the year.


mysql>  SELECT  YEARWEEK('1987-01-01');
+	+




|  YEAR('98-02-03')YEARWEEK('1987-01-01')
|
+	+

| 198653
|
+	+
1  row  in  set  (0.00  sec)


Note: The week number is different from what the WEEK() function would return (0) for optional arguments 0 or 1, as WEEK() then returns the week in the context of the given year.













SQL

38.	SQL ─ Temporary Tables
What are Temporary Tables?
There are RDBMS, which support temporary tables. Temporary Tables are a great feature that lets you store and process intermediate results by using the same selection, update, and join capabilities that you can use with typical SQL Server tables.
The temporary tables could be very useful in some cases to keep temporary data. The most important thing that should be known for temporary tables is that they will be deleted when the current client session terminates.
Temporary tables are available in MySQL version 3.23 onwards. If you use an older version of MySQL than 3.23, you can't use temporary tables, but you can use heap tables.
As stated earlier, temporary tables will only last as long as the session is alive. If you run the code in a PHP script, the temporary table will be destroyed automatically when the script finishes executing. If you are connected to the MySQL database server through the MySQL client program, then the temporary table will exist until you close the client or manually destroy the table.

Example
Here is an example showing you the usage of a temporary table.
mysql> CREATE TEMPORARY TABLE SALESSUMMARY (
->  product_name  VARCHAR(50)  NOT  NULL
->  ,  total_sales  DECIMAL(12,2)  NOT  NULL  DEFAULT  0.00
->  ,  avg_unit_price  DECIMAL(7,2)  NOT  NULL  DEFAULT  0.00
->  ,  total_units_sold  INT  UNSIGNED  NOT  NULL  DEFAULT  0
);
Query  OK,  0  rows  affected  (0.00  sec)


mysql>  INSERT  INTO  SALESSUMMARY
->  (product_name,  total_sales,  avg_unit_price,  total_units_sold)
-> VALUES
->  ('cucumber',  100.25,  90,  2);


mysql> SELECT * FROM SALESSUMMARY;
+	+	+	+	+
|  product_name  |  total_sales  |  avg_unit_price  |  total_units_sold  |
+	+	+	+	+


162


SQL



| cucumber
+ 	
|
100.25 |
90.00 |
2 |
+ 	
+ 	
+ 	
+
1 row in set (0.00 sec)
When you issue a SHOW TABLES command, then your temporary table will not be listed out in the list. Now, if you log out of the MySQL session and then issue a SELECT command, you will find no data available in the database. Even your temporary table will not be existing.

 Dropping Temporary Tables	
By default, all the temporary tables are deleted by MySQL when your database connection gets terminated. Still if you want to delete them in between, then you can do so by issuing a DROP TABLE command.
Following is an example on dropping a temporary table.
mysql> CREATE TEMPORARY TABLE SALESSUMMARY (
->  product_name  VARCHAR(50)  NOT  NULL
->  ,  total_sales  DECIMAL(12,2)  NOT  NULL  DEFAULT  0.00
->  ,  avg_unit_price  DECIMAL(7,2)  NOT  NULL  DEFAULT  0.00
->  ,  total_units_sold  INT  UNSIGNED  NOT  NULL  DEFAULT  0
);
Query  OK,  0  rows  affected  (0.00  sec)


mysql>  INSERT  INTO  SALESSUMMARY
->  (product_name,  total_sales,  avg_unit_price,  total_units_sold)
-> VALUES
->  ('cucumber',  100.25,  90,  2);


mysql> SELECT * FROM SALESSUMMARY;
+	+	+	+	+
| product_name | total_sales | avg_unit_price | total_units_sold |
+	+	+	+	+
|  cucumber	|	100.25  |	90.00  |	2  |
+	+	+	+	+
1 row in set (0.00 sec)
mysql>  DROP  TABLE  SALESSUMMARY; mysql>	SELECT * FROM SALESSUMMARY;
ERROR  1146:  Table  'TUTORIALS.SALESSUMMARY'  doesn't  exist


163













SQL

39.	SQL – Clone Tables
There may be a situation when you need an exact copy of a table and the CREATE TABLE
... or the SELECT... commands does not suit your purposes because the copy must include the same indexes, default values and so forth.
If you are using MySQL RDBMS, you can handle this situation by adhering to the steps given below:
· Use SHOW CREATE TABLE command to get a CREATE TABLE statement that specifies the source table's structure, indexes and all.
· Modify the statement to change the table name to that of the clone table and execute the statement. This way you will have an exact clone table.
· Optionally, if you need the table contents copied as well, issue an INSERT INTO or a SELECT statement too.

Example
Try out the following example to create a clone table for TUTORIALS_TBL whose structure is as follows:
Step 1: Get the complete structure about the table.
SQL> SHOW CREATE TABLE TUTORIALS_TBL \G;
*************************** 1. row *************************** Table:  TUTORIALS_TBL
Create  Table:  CREATE  TABLE  'TUTORIALS_TBL'  (
'tutorial_id'  int(11)  NOT  NULL  auto_increment, 'tutorial_title'  varchar(100)  NOT  NULL  default  '', 'tutorial_author'  varchar(40)  NOT  NULL  default  '', 'submission_date'  date  default  NULL,
PRIMARY  KEY	('tutorial_id'),
UNIQUE  KEY  'AUTHOR_INDEX'  ('tutorial_author')
) TYPE=MyISAM
1 row in set (0.00 sec)


Step 2: Rename this table and create another table.
SQL>  CREATE  TABLE  `CLONE_TBL`  (
->  'tutorial_id'  int(11)  NOT  NULL  auto_increment,
->  'tutorial_title'  varchar(100)  NOT  NULL  default  '',


164


SQL

->  'tutorial_author'  varchar(40)  NOT  NULL  default  '',
->  'submission_date'  date  default  NULL,
->  PRIMARY  KEY	(`tutorial_id'),
->  UNIQUE  KEY  'AUTHOR_INDEX'  ('tutorial_author')
->  )  TYPE=MyISAM;
Query  OK,  0  rows  affected  (1.80  sec)


Step 3: After executing step 2, you will clone a table in your database. If you want to copy data from an old table, then you can do it by using the INSERT INTO... SELECT statement.
SQL>  INSERT  INTO  CLONE_TBL  (tutorial_id,
->	tutorial_title,
->	tutorial_author,
->	submission_date)
->  SELECT  tutorial_id,tutorial_title,
->	tutorial_author,submission_date,
->  FROM  TUTORIALS_TBL;
Query  OK,  3  rows  affected  (0.07  sec) Records:  3	Duplicates:  0	Warnings:  0


Finally, you will have an exact clone table as you wanted to have.

165













SQL

40.	SQL – Sub Queries
A Subquery or Inner query or a Nested query is a query within another SQL query and embedded within the WHERE clause. A subquery is used to return data that will be used in the main query as a condition to further restrict the data to be retrieved.
Subqueries can be used with the SELECT, INSERT, UPDATE, and DELETE statements along with the operators like =, <, >, >=, <=, IN, BETWEEN, etc.
There are a few rules that subqueries must follow:
· Subqueries must be enclosed within parentheses.
· A subquery can have only one column in the SELECT clause, unless multiple columns are in the main query for the subquery to compare its selected columns.
· An ORDER BY command cannot be used in a subquery, although the main query can use an ORDER BY. The GROUP BY command can be used to perform the same function as the ORDER BY in a subquery.
· Subqueries that return more than one row can only be used with multiple value operators such as the IN operator.
· The SELECT list cannot include any references to values that evaluate to a BLOB, ARRAY, CLOB, or NCLOB.
· A subquery cannot be immediately enclosed in a set function.
· The BETWEEN operator cannot be used with a subquery. However, the BETWEEN operator can be used within the subquery.

 Subqueries with the SELECT Statement	
Subqueries are most frequently used with the SELECT statement. The basic syntax is as follows:
SELECT column_name [, column_name ] FROM	table1 [, table2 ]
WHERE	column_name OPERATOR
(SELECT  column_name  [,  column_name  ] FROM  table1  [,  table2  ]
[WHERE])


166

SQL



Example
+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
Consider the CUSTOMERS table having the following records.






|1|Ramesh|35|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

Now, let us check the following subquery with a SELECT statement.
SQL> SELECT *
FROM CUSTOMERS
WHERE  ID  IN  (SELECT  ID
FROM CUSTOMERS
WHERE SALARY > 4500) ;


+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS | SALARY
+	+	+	+	+ 	
+
|
+
|
|
|
4  |  Chaitali  |
5 | Hardik
7  |  Muffy
|
|
25 | Mumbai	|	6500.00 |
27  |  Bhopal	|	8500.00  |
24 | Indore	| 10000.00 |
+	+	+	+	+	+
This would produce the following result.


Subqueries with the INSERT Statement

Subqueries also can be used with INSERT statements. The INSERT statement uses the data returned from the subquery to insert into another table. The selected data in the subquery can be modified with any of the character, date or number functions.

170



The basic syntax is as follows.
INSERT  INTO  table_name  [  (column1  [,  column2  ])  ] SELECT  [  *|column1  [,  column2  ]
FROM  table1  [,  table2  ] [ WHERE VALUE OPERATOR ]


Example
Consider a table CUSTOMERS_BKP with similar structure as CUSTOMERS table. Now to copy the complete CUSTOMERS table into the CUSTOMERS_BKP table, you can use the following syntax.
SQL>  INSERT  INTO  CUSTOMERS_BKP SELECT * FROM CUSTOMERS WHERE  ID  IN  (SELECT  ID
FROM  CUSTOMERS)  ;


Subqueries with the UPDATE Statement
The subquery can be used in conjunction with the UPDATE statement. Either single or multiple columns in a table can be updated when using a subquery with the UPDATE statement.
The basic syntax is as follows:
UPDATE table
SET column_name = new_value [ WHERE OPERATOR [ VALUE ]
(SELECT  COLUMN_NAME FROM  TABLE_NAME)
[  WHERE)  ]


Example
Assuming, we have CUSTOMERS_BKP table available which is backup of CUSTOMERS table. The following example updates SALARY by 0.25 times in the CUSTOMERS table for all the customers whose AGE is greater than or equal to 27.
SQL> UPDATE CUSTOMERS
SET  SALARY  =  SALARY  *  0.25
WHERE  AGE  IN  (SELECT  AGE  FROM  CUSTOMERS_BKP
WHERE AGE >= 27 );




+	+	+	+	+ 	
| ID | NAME	| AGE | ADDRESS	| SALARY
+	+	+	+	+ 	
+
|
+
+	+	+	+	+	+
This would impact two rows and finally CUSTOMERS table would have the following records.






|1|Ramesh|35|Ahmedabad|125.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|2125.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|


Subqueries with the DELETE Statement
The subquery can be used in conjunction with the DELETE statement like with any other statements mentioned above.
The basic syntax is as follows.
DELETE FROM TABLE_NAME
[ WHERE OPERATOR [ VALUE ] (SELECT  COLUMN_NAME FROM  TABLE_NAME)
[  WHERE)  ]


Example
Assuming, we have a CUSTOMERS_BKP table available which is a backup of the CUSTOMERS table. The following example deletes the records from the CUSTOMERS table for all the customers whose AGE is greater than or equal to 27.
SQL> DELETE FROM CUSTOMERS
WHERE  AGE  IN  (SELECT  AGE  FROM  CUSTOMERS_BKP
WHERE AGE >= 27 );








This would impact two rows and finally the CUSTOMERS table would have the following records.

+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS | SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+



    




|2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|













SQL

41.	SQL – Using Sequences
A sequence is a set of integers 1, 2, 3, ... that are generated in order on demand. Sequences are frequently used in databases because many applications require each row in a table to contain a unique value and sequences provide an easy way to generate them.
This chapter describes how to use sequences in MySQL.

 Using AUTO_INCREMENT column	
The simplest way in MySQL to use sequences is to define a column as AUTO_INCREMENT and leave the rest to MySQL to take care.

Example
mysql> CREATE TABLE INSECT
-> (
->  id  INT  UNSIGNED  NOT  NULL  AUTO_INCREMENT,
->  PRIMARY  KEY  (id),
->  name  VARCHAR(30)  NOT  NULL,  #  type  of  insect
->  date  DATE  NOT  NULL,  #  date  collected
->  origin  VARCHAR(30)  NOT  NULL  #  where  collected
);
Query  OK,  0  rows  affected  (0.02  sec)
mysql>  INSERT  INTO  INSECT  (id,name,date,origin)  VALUES
->  (NULL,'housefly','2001-09-10','kitchen'),
->  (NULL,'millipede','2001-09-10','driveway'),
->  (NULL,'grasshopper','2001-09-10','front  yard'); Query  OK,  3  rows  affected  (0.02  sec)
Records:  3	Duplicates:  0	Warnings:  0
mysql>  SELECT  *  FROM  INSECT  ORDER  BY  id;
+	+	+	+ 	
| id | name	| date	| origin
+	+	+	+ 	
+
|
+
|	1  |  housefly	|  2001-09-10  |  kitchen	|
Try out the following example. This will create a table and after that it will insert a few rows in this table where it is not required to give a record ID because its auto-incremented by MySQL.


171

SQL





|	2  |  millipede	|  2001-09-10  |  driveway	|
|	3  |  grasshopper  |  2001-09-10  |  front  yard  |
+	+	+	+	+
3  rows  in  set  (0.00  sec)


 Obtain AUTO_INCREMENT Values	
The LAST_INSERT_ID( ) is an SQL function, so you can use it from within any client that understands how to issue SQL statements. Otherwise PERL and PHP scripts provide exclusive functions to retrieve auto-incremented value of last record.

PERL Example
Use the mysql_insertid attribute to obtain the AUTO_INCREMENT value generated by a query. This attribute is accessed through either a database handle or a statement handle, depending on how you issue the query.
The following example references it through the database handle.
$dbh->do  ("INSERT  INTO  INSECT  (name,date,origin) VALUES('moth','2001-09-14','windowsill')");
my  $seq  =  $dbh->{mysql_insertid};


PHP Example
After issuing a query that generates an AUTO_INCREMENT value, retrieve the value by calling the mysql_insert_id( ) function.
mysql_query  ("INSERT  INTO  INSECT  (name,date,origin) VALUES('moth','2001-09-14','windowsill')",  $conn_id);
$seq  =  mysql_insert_id  ($conn_id);


 Renumbering an Existing Sequence	
There may be a case when you have deleted many records from a table and you want to re-sequence all the records. This can be done by using a simple trick, but you should be very careful to do this and check if your table is having a join with another table or not.
If you determine that resequencing an AUTO_INCREMENT column is unavoidable, the way to do it is to drop the column from the table, then add it again.
The following example shows how to renumber the id values in the insect table using this technique.

173



mysql> ALTER TABLE INSECT DROP id;
mysql> ALTER TABLE insect
->  ADD  id  INT  UNSIGNED  NOT  NULL  AUTO_INCREMENT  FIRST,
->  ADD  PRIMARY  KEY  (id);


 Starting a Sequence at a Particular Value	
By default, MySQL will start the sequence from 1, but you can specify any other number as well at the time of table creation.
The following code block has an example where MySQL will start sequence from 100.
mysql> CREATE TABLE INSECT
-> (
->  id  INT  UNSIGNED  NOT  NULL  AUTO_INCREMENT  =  100,
->  PRIMARY  KEY  (id),
->  name  VARCHAR(30)  NOT  NULL,  #  type  of  insect
->  date  DATE  NOT  NULL,  #  date  collected
->  origin  VARCHAR(30)  NOT  NULL  #  where  collected
);


Alternatively, you can create the table and then set the initial sequence value with ALTER TABLE.
mysql>  ALTER  TABLE  t  AUTO_INCREMENT  =  100;














SQL

42.	SQL – Handling Duplicates
There may be a situation when you have multiple duplicate records in a table. While fetching such records, it makes more sense to fetch only unique records instead of fetching duplicate records.
The SQL DISTINCT keyword, which we have already discussed is used in conjunction with the SELECT statement to eliminate all the duplicate records and by fetching only the unique records.

Syntax
The basic syntax of a DISTINCT keyword to eliminate duplicate records is as follows.
SELECT DISTINCT column1, column2,.	columnN
FROM table_name WHERE [condition]


Example
Consider the CUSTOMERS table having the following records.






|1|Ramesh|32|Ahmedabad|2000.00||2|Khilan|25|Delhi|1500.00||3|kaushik|23|Kota|2000.00||4|Chaitali|25|Mumbai|6500.00||5|Hardik|27|Bhopal|8500.00||6|Komal|22|MP|4500.00||7|Muffy|24|Indore|10000.00|

+	+	+	+	+	+
| ID | NAME	| AGE | ADDRESS	| SALARY	|
+	+	+	+	+	+
+	+	+	+	+	+
First, let us see how the following SELECT query returns duplicate salary records.
SQL> SELECT SALARY FROM CUSTOMERS ORDER  BY  SALARY;


174


SQL


This would produce the following result where the salary of 2000 is coming twice which is a duplicate record from the original table.
+	+
| SALARY	|
+	+
|	1500.00 |
|	2000.00  |
|	2000.00 |
|	4500.00 |
|	6500.00 |
|	8500.00 |
| 10000.00 |
+	+


Now, let us use the DISTINCT keyword with the above SELECT query and see the result.
SQL> SELECT DISTINCT SALARY FROM CUSTOMERS ORDER  BY  SALARY;


This would produce the following result where we do not have any duplicate entry.
+	+
| SALARY	|
+	+
|	1500.00 |
|	2000.00 |
|	4500.00 |
|	6500.00 |
|	8500.00 |
| 10000.00 |
+	+


175













SQL

43.	SQL – Injection
If you take a user input through a webpage and insert it into a SQL database, there is a chance that you have left yourself wide open for a security issue known as the SQL Injection. This chapter will teach you how to help prevent this from happening and help you secure your scripts and SQL statements in your server side scripts such as a PERL Script.
Injection usually occurs when you ask a user for input, like their name and instead of a name they give you a SQL statement that you will unknowingly run on your database. Never trust user provided data, process this data only after validation; as a rule, this is done by Pattern Matching.
In the example below, the name is restricted to the alphanumerical characters plus underscore and to a length between 8 and 20 characters (modify these rules as needed).
if  (preg_match("/^\w{8,20}$/",  $_GET['username'],  $matches))
{
$result  =  mysql_query("SELECT  *  FROM  CUSTOMERS
WHERE  name=$matches[0]");
}
else
{
echo  "user  name  not  accepted";
}


To demonstrate the problem, consider this excerpt:
//  supposed  input
$name = "Qadir'; DELETE FROM CUSTOMERS;";
mysql_query("SELECT * FROM CUSTOMSRS WHERE name='{$name}'");


The function call is supposed to retrieve a record from the CUSTOMERS table where the name column matches the name specified by the user. Under normal circumstances,
$name would only contain alphanumeric characters and perhaps spaces, such as the string ilia. But here, by appending an entirely new query to $name, the call to the database turns into disaster; the injected DELETE query removes all records from the CUSTOMERS table.
Fortunately, if you use MySQL, the mysql_query() function does not permit query stacking or executing multiple SQL queries in a single function call. If you try to stack queries, the call fails.
However, other PHP database extensions, such as SQLite and PostgreSQL happily perform stacked queries, executing all the queries provided in one string and creating a serious security problem.

176


SQL

 Preventing SQL Injection	
You can handle all escape characters smartly in scripting languages like PERL and PHP. The MySQL extension for PHP provides the function mysql_real_escape_string() to escape input characters that are special to MySQL.
if (get_magic_quotes_gpc())
{
$name  =  stripslashes($name);
}
$name   =   mysql_real_escape_string($name); mysql_query("SELECT * FROM CUSTOMERS WHERE name='{$name}'");


The LIKE Quandary
To address the LIKE quandary, a custom escaping mechanism must convert user-supplied '%' and '_' characters to literals. Use addcslashes(), a function that lets you specify a character range to escape.
$sub = addcslashes(mysql_real_escape_string("%str"), "%_");
//  $sub  ==  \%str\_ mysql_query("SELECT * FROM messages
WHERE  subject  LIKE  '{$sub}%'");

177

